<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ANTONIOS INTELIGENCE</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext y='50' font-size='48'%3E%E2%9C%A8%3C/text%3E%3C/svg%3E">
    <script>
        window.__firebase_config = {
            apiKey: "AIzaSyA9Rl785wVd6NVgdNqU_5lsy36dHYnLMlE",
            authDomain: "raydent-16571.firebaseapp.com",
            projectId: "raydent-16571",
            storageBucket: "raydent-16571.firebasestorage.app",
            messagingSenderId: "904932609815",
            appId: "1:904932609815:web:21147268961e89870a3152",
            measurementId: "G-42YE0D1F68"
        };
    </script>
    <link href="styles/tailwind.generated.css" rel="stylesheet" />
    <link href="https://vjs.zencdn.net/8.10.0/video-js.css" rel="stylesheet" />
    <script src="https://vjs.zencdn.net/8.10.0/video.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f1b0a; /* Dark gold/brown background */
            color: #e0e0e0;
            overflow: hidden; /* Prevent body scroll */
            display: flex;
            flex-direction: row-reverse; /* Sidebar on right, camera on left */
            height: 100vh;
            margin: 0;
        }
        
        #balance-modal > div::-webkit-scrollbar {
            width: 8px;
        }
        #balance-modal > div::-webkit-scrollbar-track {
            background: #2d2d2d;
            border-radius: 4px;
        }
        #balance-modal > div::-webkit-scrollbar-thumb {
            background: #ffc400;
            border-radius: 4px;
        }
        #balance-modal > div::-webkit-scrollbar-thumb:hover {
            background: #e6b800;
        
                /* Gift Animation Overlay */
                #camera-gift-overlay {
                    position: absolute;
                    inset: 0;
                    pointer-events: none;
                    overflow: hidden;
                    z-index: 998;
                }
                .gift-animation {
                    position: absolute;
                    font-size: 3rem;
                    pointer-events: none;
                    animation: floatUp 3s ease-out forwards;
                    z-index: 1000;
                }
        
                @keyframes floatUp {
                    0% {
                        opacity: 1;
                        transform: translateY(0) scale(0.5);
                    }
                    50% {
                        opacity: 1;
                        transform: translateY(-50px) scale(1.2);
                    }
                    100% {
                        opacity: 0;
                        transform: translateY(-150px) scale(1) rotate(20deg);
                    }
                }
        
                .gift-notification {
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(45deg, #ffc400, #ff6b9d);
                    color: white;
                    padding: 1.5rem 2rem;
                    border-radius: 1rem;
                    font-size: 1.5rem;
                    font-weight: bold;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
                    pointer-events: none;
                    z-index: 1001;
                    animation: giftPop 2s ease-out forwards;
                }
        
                @keyframes giftPop {
                    0% {
                        opacity: 0;
                        transform: translate(-50%, -50%) scale(0.3);
                    }
                    20% {
                        opacity: 1;
                        transform: translate(-50%, -50%) scale(1.1);
                    }
                    80% {
                        opacity: 1;
                        transform: translate(-50%, -50%) scale(1);
                    }
                    100% {
                        opacity: 0;
                        transform: translate(-50%, -50%) scale(0.8);
                    }
                }
        }
        .sidebar {
            background-color: rgba(60, 50, 20, 0.9); /* Semi-transparent background */
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            width: 450px; /* Fixed width, always visible */
            height: 100vh;
            overflow-y: auto;
            padding: 1rem;
            border-left: 2px solid #a67c00;
            position: relative;
            z-index: 10;
            flex-shrink: 0;
        }
        .sidebar.collapsed {
            width: 0;
            padding: 0;
            border-left: 0;
            overflow: hidden;
        }
        .sidebar-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            position: sticky;
            top: 0;
            z-index: 11;
            padding-bottom: 0.5rem;
            background: linear-gradient(180deg, rgba(60, 50, 20, 0.95), rgba(60, 50, 20, 0));
        }
        .icon-btn {
            width: 2.25rem;
            height: 2.25rem;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }
        .sidebar-locked-open {
            width: 450px;
        }
        .sidebar-locked-open:hover {
            width: 450px;
        }
        .card {
            background-color: rgba(80, 70, 30, 0.7); /* Semi-transparent card */
            border-radius: 1rem;
            padding: 1rem;
            margin-top: 1rem;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
            border: 1px solid #b58c00;
        }
        #sidebar-toggle-btn {
            display: inline-flex;
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 2001;
        }
        input, button, select {
            background-color: #3d3419;
            border: 1px solid #a67c00;
            color: #e0e0e0;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            margin: 0.5rem 0;
            width: 100%;
            transition: all 0.3s ease;
        }
        input:focus, button:focus, select:focus {
            outline: none;
            border-color: #ffc400;
            box-shadow: 0 0 0 3px rgba(255, 196, 0, 0.5);
        }
        button {
            cursor: pointer;
            background: linear-gradient(45deg, #ffc400, #e6b800);
            border: none;
            color: #1f1b0a;
        }
        button:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }
        .video-js {
            margin: 0 auto;
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: 2px solid #b58c00;
        }
        .avatar {
            width: 150px;
            height: 150px;
            margin: 0.5rem;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid #e6b800;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        .file-upload-container {
            border: 2px dashed #a67c00;
            border-radius: 1rem;
            padding: 1rem;
            margin-top: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .file-upload-container label {
            cursor: pointer;
            background-color: #a67c00;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s ease;
        }
        .file-upload-container label:hover {
            background-color: #ffc400;
        }
        .hidden {
            display: none;
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #1e1e3f;
            color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
            text-align: center;
        }
        .chat-container {
            background-color: #2b2b2b;
            border-radius: 1rem;
            height: 400px;
            overflow-y: scroll;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .chat-message {
            max-width: 80%;
            padding: 0.75rem;
            border-radius: 0.75rem;
						display: flex;
            align-items: center;
        }
        .user-message {
            background-color: #8c6f1a;
            align-self: flex-end;
            text-align: right;
        }
        .ai-message {
            background-color: #4f4520;
            align-self: flex-start;
            text-align: left;
        }
        .zodiac-container {
            position: relative;
            flex: 1 1 auto;
            min-width: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1f1b0a;
            overflow: hidden;
            z-index: 1;
        }
        #camera-controls {
            position: absolute;
            top: 16px;
            left: 16px;
            right: 16px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 0.5rem;
            z-index: 2000;
            pointer-events: none;
        }
        .camera-action-bar {
            position: relative;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            background: rgba(0, 0, 0, 0.35);
            padding: 0.4rem;
            border-radius: 0.6rem;
            -webkit-backdrop-filter: blur(6px);
            backdrop-filter: blur(6px);
            pointer-events: auto;
        }
        .camera-action-bar.right {
            justify-content: flex-end;
        }
        .camera-action-btn {
            background: linear-gradient(45deg, #ffc400, #e6b800);
            color: #1f1b0a;
            border: none;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
            width: auto;
        }
        .camera-action-select {
            background-color: #3d3419;
            border: 1px solid #a67c00;
            color: #e0e0e0;
            padding: 0.4rem 0.6rem;
            border-radius: 0.5rem;
            font-size: 0.7rem;
            width: auto;
            max-width: 220px;
        }
        .camera-action-btn:hover {
            opacity: 0.9;
        }
        .zodiac-container video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .bad-d-girl-status {
            background-color: #3d3419;
            border-radius: 1rem;
            padding: 1.5rem;
            margin-top: 1.5rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid #a67c00;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .bad-d-girl-status .avatar {
            border-color: #e6b800;
            filter: grayscale(100%);
        }
        .bad-d-girl-status.approved .avatar {
            border-color: #ffc400;
            filter: none;
        }
        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-top: 0.5rem;
        }
        .status-waiting { background-color: #e6b800; color: black; }
        .status-approved { background-color: #ffc400; color: black; }
        .call-videos {
            position: relative;
            width: 100%;
            height: 500px;
            background: #000;
            border-radius: 0.75rem;
            overflow: hidden;
        }
        .call-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #remote-call-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 100;
            display: none;
        }
        #local-call-video {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            border-radius: 0.5rem;
            border: 2px solid #e6b800;
            z-index: 101;
        }
        #broadcast-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            object-fit: cover;
            z-index: 90;
            display: none;
        }
        .call-id {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.75rem;
            color: #e6b800;
            word-break: break-all;
        }
        .admin-only {
            display: none;
        }
        .page-nav-btn {
            transition: all 0.3s ease;
        }
        .page-nav-btn.active {
            border-bottom: 3px solid #e6b800;
            font-weight: bold;
        }
        .page-content {
            transition: opacity 0.3s ease;
        }
        .page-content.hidden {
            display: none;
        }
        #page-chat:not(.hidden) {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 200px);
        }
        .page-chat-card {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }
        .floating-chat-messages-panel {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border: 1px solid #a67c00;
            min-height: 200px;
        }
        .floating-chat-input-custom {
            background-color: #3d3419;
            border: 1px solid #a67c00;
            color: #e0e0e0;
            padding: 0.5rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
        }
        .floating-chat-send-btn {
            background: linear-gradient(45deg, #64c800, #4a9600);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            font-size: 0.75rem;
            width: auto;
            flex-shrink: 0;
        }
        .balance-modal-panel {
            max-height: 90vh;
            overflow-y: auto;
        }
        .gift-card {
            background: linear-gradient(135deg, #8c6f1a 0%, #5f5110 100%);
            border: 2px solid #e6b800;
            border-radius: 1rem;
            padding: 1rem;
            text-align: center;
            transition: all 0.3s ease;
        }
        .gift-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(230, 184, 0, 0.4);
        }
        .gift-card .gift-emoji {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }
        .gift-card-title {
            font-weight: bold;
            color: #e6b800;
            margin-bottom: 0.5rem;
        }
        .gift-card-price {
            font-size: 0.875rem;
            color: #10b981;
            margin-bottom: 0.5rem;
        }
        .gift-buy-btn {
            width: 100%;
            background: linear-gradient(45deg, #ffc400, #e6b800);
            border: none;
            color: #1f1b0a;
            padding: 0.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .gift-buy-btn:hover:not(:disabled) {
            opacity: 0.9;
            transform: scale(1.05);
        }
        .gift-buy-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #999;
        }
        @keyframes fadeInGift {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        @keyframes fadeOutGift {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0.8);
            }
        }
        #gift-animation.show {
            display: flex !important;
        }
        .gift-float {
            position: absolute;
            font-size: 3rem;
            animation: giftFloat 3.5s ease-in-out forwards;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
            pointer-events: none;
        }
        @keyframes giftFloat {
            0% { transform: translateY(40px) scale(0.9); opacity: 0; }
            15% { opacity: 1; }
            100% { transform: translateY(-180px) scale(1.2); opacity: 0; }
        }
        .camera-chat {
            position: fixed;
            bottom: 20px;
            left: 20px;
            transform: none;
            width: 360px;
            max-height: 500px;
            background: transparent;
            -webkit-backdrop-filter: none;
            backdrop-filter: none;
            border-radius: 1rem;
            border: none;
            display: flex;
            flex-direction: column;
            z-index: 2000;
        }
        .camera-chat-header {
            padding: 0.75rem;
            border-bottom: none;
            font-weight: bold;
            color: #ffc400;
            font-size: 0.875rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .camera-chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 0.75rem;
            max-height: 250px;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .camera-chat-message {
            background: rgba(80, 70, 30, 0.6);
            padding: 0.5rem;
            border-radius: 0.5rem;
            font-size: 0.75rem;
        }
        .camera-chat-sender {
            color: #ffc400;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 0.25rem;
        }
        .camera-chat-sender:hover {
            text-decoration: underline;
        }
        .camera-chat-text {
            color: #e0e0e0;
        }
        .camera-chat-input-container {
            padding: 0.75rem;
            border-top: 1px solid #a67c00;
            display: flex;
            gap: 0.5rem;
        }
        .camera-chat-input {
            flex: 1;
            background: #2b2417;
            border: 1px solid #a67c00;
            color: #e0e0e0;
            padding: 0.5rem;
            border-radius: 0.5rem;
            font-size: 0.75rem;
        }
        .camera-chat-send {
            background: linear-gradient(45deg, #ffc400, #e6b800);
            border: none;
            color: #1f1b0a;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            font-size: 0.75rem;
        }
        .camera-chat-send:hover {
            opacity: 0.9;
        }
        .camera-chat.minimized .camera-chat-messages,
        .camera-chat.minimized .camera-chat-input-container {
            display: none;
        }
        #floating-chat {
            display: none !important;
        }
        /* User Profile Card Styles */
        .user-profile-card {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1));
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 0.5rem;
            transition: all 0.2s;
        }
        .user-profile-card:hover {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2));
            border-color: rgba(139, 92, 246, 0.5);
        }
        .user-profile-photo {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid rgba(139, 92, 246, 0.5);
            flex-shrink: 0;
        }
        .user-profile-photo-small {
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
            object-fit: cover;
            border: 1px solid rgba(139, 92, 246, 0.5);
            flex-shrink: 0;
        }
        .user-profile-info {
            flex: 1;
            min-width: 0;
        }
        .user-profile-name {
            font-weight: 600;
            font-size: 0.95rem;
            color: #fbbf24;
            word-break: break-word;
        }
        .user-profile-status {
            font-size: 0.75rem;
            color: #9ca3af;
        }
        .user-profile-actions {
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0;
        }
        .online-user-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: rgba(55, 65, 81, 0.5);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 0.375rem;
            margin-bottom: 0.5rem;
            transition: all 0.2s;
            cursor: pointer;
        }
        .online-user-item:hover {
            background: rgba(75, 85, 99, 0.7);
            border-color: rgba(139, 92, 246, 0.4);
        }
        .online-user-item.self {
            background: rgba(55, 65, 81, 0.7);
            border-color: rgba(34, 197, 94, 0.3);
        }
    </style>
</head>
<body>

    <!-- Full-screen video background -->
    <div id="video-background" class="zodiac-container">
        <video id="localVideo" autoplay playsinline></video>
        <video id="broadcast-video" autoplay playsinline class="hidden"></video>

        <div id="camera-controls">
            <div class="camera-action-bar" id="camera-controls-left">
                <button id="buy-balance-btn-camera" class="camera-action-btn">üí≥ Buy Balance</button>
                <button id="go-live-btn" class="camera-action-btn">üì° Go Live</button>
                <button id="end-live-btn" class="camera-action-btn hidden">‚èπ End Live</button>
                <button id="enable-camera-btn" class="camera-action-btn">üé• Enable Camera</button>
                <button id="mic-toggle-btn" class="camera-action-btn">üé§ Mic On</button>
                <button id="monitor-toggle-btn" class="camera-action-btn">üîä Monitor Off</button>
                <select id="mic-select" class="camera-action-select" title="Microphone source"></select>
                <span id="broadcast-status" class="text-xs text-emerald-300 font-bold ml-2"></span>
            </div>
            <div class="camera-action-bar right" id="camera-controls-right">
                <span id="app-host-display-camera" class="text-xs text-gray-300 font-mono" title="Current app host"></span>
                <button id="host-mode-btn" class="camera-action-btn">üëë Host Mode Off</button>
            </div>
        </div>
        
            <!-- Gift Animation Overlay -->
            <div id="camera-gift-overlay"></div>
        
        <!-- Video Call Overlay (hidden by default, shown during calls) -->
        <video id="remote-call-video" class="call-video hidden" autoplay playsinline></video>
        <video id="local-call-video" class="call-video hidden" autoplay playsinline muted></video>
        <audio id="mic-monitor" autoplay playsinline class="hidden"></audio>
        
            <!-- Camera Chat Overlay -->
            <div id="camera-chat" class="camera-chat">
                <div class="camera-chat-header">
                    <span>üí¨ Global Chat</span>
                    <button id="toggle-chat-btn" class="text-white text-sm hover:text-yellow-400">‚ûñ</button>
                </div>
                <div class="camera-chat-messages" id="camera-chat-messages">
                    <!-- Messages will appear here -->
                </div>
                <div class="camera-chat-input-container">
                    <input type="text" id="camera-chat-input" class="camera-chat-input" placeholder="Send a message..." maxlength="200">
                    <button id="camera-chat-send" class="camera-chat-send">Send</button>
                </div>
            </div>

    </div>

    <button id="sidebar-toggle-btn" class="icon-btn" aria-label="Close sidebar">‚¨ÖÔ∏è</button>

    <!-- Main content container as an overlay sidebar -->
    <main class="sidebar">
        <div class="sidebar-controls">
            <button id="share-app-btn" class="icon-btn" aria-label="Share app">üîó</button>
            <div id="build-stamp" class="text-[10px] text-gray-400 ml-auto">Build: 2026-02-11</div>
        </div>
        <div id="app-content">
            <!-- Page Navigation -->
            <div class="flex gap-1 mb-4 border-b border-gray-600 pb-2 overflow-x-auto">
                <button class="page-nav-btn text-xs px-3 py-1 rounded-t-lg bg-purple-600 hover:bg-purple-700 active" data-page="home">üè† Home</button>
                <button class="page-nav-btn text-xs px-3 py-1 rounded-t-lg bg-blue-600 hover:bg-blue-700" data-page="account">üë§ Account</button>
                <button class="page-nav-btn text-xs px-3 py-1 rounded-t-lg bg-green-600 hover:bg-green-700" data-page="chat">üí¨ Chat</button>
                <button class="page-nav-btn text-xs px-3 py-1 rounded-t-lg bg-pink-600 hover:bg-pink-700" data-page="studio">üé§ Studio</button>
                <button class="page-nav-btn text-xs px-3 py-1 rounded-t-lg bg-yellow-600 hover:bg-yellow-700" data-page="zodiac">‚≠ê Council</button>
                <button class="page-nav-btn text-xs px-3 py-1 rounded-t-lg bg-cyan-600 hover:bg-cyan-700" data-page="online">üü¢ Online (<span id="nav-online-count">0</span>)</button>
            </div>

            <!-- Home Page -->
            <div class="page-content active" id="page-home">
                <p id="prompt-message" class="text-xl font-bold mb-4 text-center">Please approve camera and microphone permissions to begin.</p>
                
                <!-- Pisces Ghost and First Lady Side by Side -->
                <div class="flex justify-center gap-8 mb-6">
                    <!-- Pisces Ghost Column -->
                    <div class="flex flex-col items-center">
                        <img id="user-avatar" class="avatar" src="https://placehold.co/150x150/5a4b8a/ffffff?text=Pisces+Ghost" alt="Pisces Ghost's Avatar">
                        <p class="mt-2 text-xl font-bold" id="user-name-display">Pisces Ghost</p>
                        <p class="text-sm text-gray-400" id="zodiac-sign-display">Zodiac Sign: Pisces Ghost</p>
                        <button id="generate-avatar-btn" class="text-sm mt-2 p-2 rounded-lg bg-purple-600 hover:bg-purple-700">üì∑ Upload Photo</button>
                        <label for="pisces-avatar-upload" class="sr-only">Upload Pisces avatar</label>
                        <input type="file" id="pisces-avatar-upload" accept="image/*" class="hidden" title="Upload Pisces avatar" aria-label="Upload Pisces avatar">
                    </div>

                    <!-- First Lady Column -->
                    <div class="flex flex-col items-center">
                        <img id="Good-D-Girl-avatar" class="avatar" src="https://placehold.co/150x150/7c3aed/ffffff?text=BadDGirl" alt="BadDGirl's Avatar">
                        <p class="mt-2 text-xl font-bold">GoodDGirl</p>
                        <p class="text-sm text-gray-400">The First Lady</p>
                        <button id="change-first-lady-btn" class="text-xs mt-2 p-1 rounded-lg bg-pink-600 hover:bg-pink-700 admin-only">üì∑ Change Photo</button>
                    </div>
                </div>

                <!-- Producer Below -->
                <div class="flex justify-center mb-6">
                    <div class="flex flex-col items-center">
                        <img id="producer-avatar" class="avatar" src="https://placehold.co/150x150/a67c00/ffffff?text=Producer" alt="Producer's Avatar">
                        <p class="mt-2 text-xl font-bold">BABY RAY</p>
                        <p class="text-sm text-gray-400">The Producer</p>
                    </div>
                </div>

                <!-- Account Section -->
                <div id="account-section-home" class="card text-center">
                    <p class="text-sm font-bold mb-3">Account</p>
                    <button id="google-sign-in-btn-home" class="w-full mb-2 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-3 rounded-lg text-sm">üîê Sign in with Google</button>
                    <div class="flex gap-1 mb-2">
                        <input id="auth-email" type="email" placeholder="Email" class="flex-1 mb-0" />
                        <input id="auth-password" type="password" placeholder="Password" class="flex-1 mb-0" />
                    </div>
                    <div class="flex flex-wrap gap-1 justify-center mb-2">
                        <button id="sign-up-btn" class="text-xs bg-purple-600 hover:bg-purple-700 px-2 py-1">Create</button>
                        <button id="sign-in-btn" class="text-xs bg-blue-600 hover:bg-blue-700 px-2 py-1">Sign In</button>
                        <button id="sign-out-btn" class="text-xs bg-gray-600 hover:bg-gray-700 px-2 py-1" disabled>Out</button>
                    </div>
                    <button id="copy-email-btn-home" class="w-full mb-2 bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-2 rounded-lg text-xs" disabled>üìã Copy My Email</button>
                    
                    <!-- Balance Section -->
                    <div class="mt-3 pt-3 border-t border-gray-600">
                        <p class="text-xs font-bold text-yellow-400">üí∞ Balance: <span id="balance-home">0</span> credits</p>
                        <button id="buy-balance-btn-home" class="w-full mt-2 bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-1 px-2 rounded-lg text-xs">üí≥ Buy Balance</button>
                    </div>
                    
                    <p class="text-xs text-gray-400 mt-2"><span id="auth-status">Checking‚Ä¶</span></p>
                    <p class="text-xs text-gray-500 mt-1">Host: <span id="app-host-display" class="font-mono"></span></p>
                </div>

                <!-- Gift Box Section -->
                <div id="gift-box-home" class="card">
                    <p class="text-sm font-bold text-center mb-3">Send Gifts</p>
                    <div class="flex justify-center">
                        <button id="giftbox-icon-home" class="text-6xl hover:scale-110 transition-transform cursor-pointer">üéÅ</button>
                    </div>
                    <p class="text-xs text-center mt-3">Gifts Received: <span id="gift-count-home" class="text-emerald-400">0</span></p>
                </div>

                <p class="text-xs text-gray-500 my-2">Your User ID: <span id="user-id-display" class="font-mono text-xs"></span></p>
            </div>

            <!-- Account Page -->
            <div class="page-content hidden" id="page-account">
                <div id="auth-section" class="card">
                    <h2 class="text-2xl font-bold mb-4">Account</h2>
                    <button id="google-sign-in-btn" class="w-full mb-4 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">üîê Sign in with Google</button>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-2 mb-3">
                        <input id="auth-email-2" type="email" placeholder="Email" />
                        <input id="auth-password-2" type="password" placeholder="Password" />
                    </div>
                    <div class="flex flex-wrap gap-2 mt-3 mb-3">
                        <button id="sign-up-btn-2" class="bg-purple-600 hover:bg-purple-700">Create Account</button>
                        <button id="sign-in-btn-2" class="bg-blue-600 hover:bg-blue-700">Sign In</button>
                        <button id="sign-out-btn-2" class="bg-gray-600 hover:bg-gray-700" disabled>Sign Out</button>
                    </div>
                    <button id="copy-email-btn" class="w-full mb-3 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg" disabled>üìã Copy My Email to Share</button>
                    
                    <!-- Profile Section -->
                    <div class="mt-4 pt-4 border-t border-gray-600">
                        <h3 class="text-lg font-bold mb-3">üë§ My Profile</h3>
                        <div class="text-center mb-3">
                            <img id="user-profile-photo" class="avatar w-24 h-24 mx-auto rounded-lg border-2 border-yellow-500 mb-2" src="https://placehold.co/150x150/gray/white?text=No+Photo" alt="Profile Photo">
                            <button id="upload-profile-photo-btn" class="bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-2 px-3 rounded">üì∑ Change Photo</button>
                            <label for="profile-photo-upload" class="sr-only">Upload profile photo</label>
                            <input id="profile-photo-upload" type="file" accept="image/*" class="hidden" title="Upload profile photo" aria-label="Upload profile photo">
                        </div>
                        <input id="user-username" type="text" placeholder="Enter your username" maxlength="30" class="w-full mb-2 bg-gray-800 border border-gray-700 text-white p-2 rounded text-sm">
                        <button id="save-profile-btn" class="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-4 rounded-lg text-sm">üíæ Save Profile</button>
                        <p id="profile-status" class="text-xs text-gray-400 mt-2"></p>
                    </div>
                    
                    <!-- Balance Section -->
                    <div class="mt-3 pt-3 border-t border-gray-600">
                        <p class="text-sm font-bold text-yellow-400">üí∞ Balance: <span id="balance-account">0</span> credits</p>
                        <button id="buy-balance-btn-account" class="w-full mt-2 bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg">üí≥ Buy Balance</button>
                    </div>
                    
                    <p class="text-xs text-gray-400 mt-3">Status: <span id="auth-status-2">Checking‚Ä¶</span></p>
                </div>
            </div>

            <!-- Gifts Page -->
            <div class="page-content hidden" id="page-gifts">
                <div id="gift-box-section" class="card">
                    <h2 class="text-2xl font-bold mb-4">üéÅ Gift Box</h2>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 mb-4">
                        <div class="bg-yellow-900 p-3 rounded-lg">
                            <p class="font-bold text-sm">üå† Shooting Star</p>
                            <p class="text-xs text-gray-400">Credits Purchase</p>
                            <button class="gift-purchase-btn text-xs mt-2 bg-yellow-600 hover:bg-yellow-700" data-gift="shooting-star" data-price="50.00" data-checkout-url="https://buy.stripe.com/cNibJ19xr6vQ5MAgQa7EQ0L">Buy Credits</button>
                        </div>
                        <div class="bg-pink-900 p-3 rounded-lg">
                            <p class="font-bold text-sm">üéÜ Heart Fireworks</p>
                            <p class="text-xs text-gray-400">Credits Purchase</p>
                            <button class="gift-purchase-btn text-xs mt-2 bg-pink-600 hover:bg-pink-700" data-gift="heart-fireworks" data-price="50.00" data-checkout-url="https://buy.stripe.com/cNibJ19xr6vQ5MAgQa7EQ0L">Buy Credits</button>
                        </div>
                        <div class="bg-amber-900 p-3 rounded-lg">
                            <p class="font-bold text-sm">ü•Ç Champagne Toast</p>
                            <p class="text-xs text-gray-400">Credits Purchase</p>
                            <button class="gift-purchase-btn text-xs mt-2 bg-amber-600 hover:bg-amber-700" data-gift="champagne-toast" data-price="50.00" data-checkout-url="https://buy.stripe.com/cNibJ19xr6vQ5MAgQa7EQ0L">Buy Credits</button>
                        </div>
                        <div class="bg-rose-900 p-3 rounded-lg">
                            <p class="font-bold text-sm">üåπ Rose</p>
                            <p class="text-xs text-gray-400">Credits Purchase</p>
                            <button class="gift-purchase-btn text-xs mt-2 bg-rose-600 hover:bg-rose-700" data-gift="rose" data-price="50.00" data-checkout-url="https://buy.stripe.com/cNibJ19xr6vQ5MAgQa7EQ0L">Buy Credits</button>
                        </div>
                    </div>
                    <div id="gift-recipient-form" class="hidden border-t border-gray-600 pt-3 mt-3">
                        <p class="text-xs font-bold mb-2">Send to:</p>
                        <input id="gift-recipient-email" type="email" placeholder="Recipient email" class="w-full mb-2" />
                        <button id="gift-confirm-btn" class="bg-emerald-600 hover:bg-emerald-700 text-xs w-full">Confirm Gift</button>
                    </div>
                    <div id="gifts-received" class="mt-3 pt-3 border-t border-gray-600">
                        <p class="text-xs font-bold mb-2">Gifts Received: <span id="gift-count" class="text-emerald-400">0</span></p>
                    </div>
                </div>
            </div>

            <!-- Call Page -->
            <div class="page-content hidden" id="page-call">
                <div class="card text-center">
                    <h2 class="text-3xl font-bold mb-4">üìπ Video Calling</h2>
                    <p class="text-lg mb-4">Video calling is integrated with the camera on the <strong>Home</strong> page!</p>
                    <p class="text-sm text-gray-400 mb-6">Look for the "Online Users" panel on the right side of the camera view. Click any online user to start a video call.</p>
                    <button onclick="document.querySelector('[data-page=home]').click()" class="bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white font-bold py-3 px-6 rounded-lg">
                        Go to Home Page
                    </button>
                </div>
            </div>

            <!-- Studio Page -->
            <div class="page-content hidden" id="page-studio">
                <div id="beat-purchase-section" class="card">
                    <h2 class="text-2xl font-bold mb-4">üéµ Studio & Beats</h2>
                <h2 class="text-2xl font-bold mb-4 text-center">The Zodiac Council</h2>
                <button class="toggle-admin-btn mb-4 bg-orange-600 hover:bg-orange-700 text-white font-bold py-1 px-3 rounded text-sm">üîì Admin Mode</button>
                <div class="grid grid-cols-3 sm:grid-cols-4 gap-4 text-center">
                    <!-- Aries -->
                    <div class="flex flex-col items-center zodiac-member" data-sign="aries">
                        <img src="https://placehold.co/100x100/ff4500/ffffff?text=Aries" alt="Aries" class="avatar w-20 h-20 zodiac-avatar">
                        <p class="mt-2 font-semibold text-sm">Aries</p>
                        <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                    </div>
                    <!-- Taurus -->
                    <div class="flex flex-col items-center zodiac-member" data-sign="taurus">
                        <img src="https://placehold.co/100x100/228B22/ffffff?text=Taurus" alt="Taurus" class="avatar w-20 h-20 zodiac-avatar">
                        <p class="mt-2 font-semibold text-sm">Taurus</p>
                        <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                    </div>
                    <!-- Gemini -->
                    <div class="flex flex-col items-center zodiac-member" data-sign="gemini">
                        <img src="https://placehold.co/100x100/ffd700/ffffff?text=Gemini" alt="Gemini" class="avatar w-20 h-20 zodiac-avatar">
                        <p class="mt-2 font-semibold text-sm">Gemini</p>
                        <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                    </div>
                    <!-- Cancer -->
                    <div class="flex flex-col items-center zodiac-member" data-sign="cancer">
                        <img src="https://placehold.co/100x100/c0c0c0/ffffff?text=Cancer" alt="Cancer" class="avatar w-20 h-20 zodiac-avatar">
                        <p class="mt-2 font-semibold text-sm">Cancer</p>
                        <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                    </div>
                    <!-- Leo -->
                    <div class="flex flex-col items-center zodiac-member" data-sign="leo">
                        <img src="https://placehold.co/100x100/ff8c00/ffffff?text=Leo" alt="Leo" class="avatar w-20 h-20 zodiac-avatar">
                        <p class="mt-2 font-semibold text-sm">Leo</p>
                        <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                    </div>
                    <!-- Virgo -->
                    <div class="flex flex-col items-center zodiac-member" data-sign="virgo">
                        <img src="https://placehold.co/100x100/9acd32/ffffff?text=Virgo" alt="Virgo" class="avatar w-20 h-20 zodiac-avatar">
                        <p class="mt-2 font-semibold text-sm">Virgo</p>
                        <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                    </div>
                    <!-- Libra -->
                    <div class="flex flex-col items-center zodiac-member" data-sign="libra">
                        <img src="https://placehold.co/100x100/ff69b4/ffffff?text=Libra" alt="Libra" class="avatar w-20 h-20 zodiac-avatar">
                        <p class="mt-2 font-semibold text-sm">Libra</p>
                        <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                    </div>
                    <!-- Scorpio -->
                    <div class="flex flex-col items-center zodiac-member" data-sign="scorpio">
                        <img src="https://placehold.co/100x100/800000/ffffff?text=Scorpio" alt="Scorpio" class="avatar w-20 h-20 zodiac-avatar">
                        <p class="mt-2 font-semibold text-sm">Scorpio</p>
                        <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                    </div>
                    <!-- Sagittarius -->
                    <div class="flex flex-col items-center zodiac-member" data-sign="sagittarius">
                        <img src="https://placehold.co/100x100/4b0082/ffffff?text=Sagittarius" alt="Sagittarius" class="avatar w-20 h-20 zodiac-avatar">
                        <p class="mt-2 font-semibold text-sm">Sagittarius</p>
                        <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                    </div>
                    <!-- Capricorn -->
                    <div class="flex flex-col items-center zodiac-member" data-sign="capricorn">
                        <img src="https://placehold.co/100x100/696969/ffffff?text=Capricorn" alt="Capricorn" class="avatar w-20 h-20 zodiac-avatar">
                        <p class="mt-2 font-semibold text-sm">Capricorn</p>
                        <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                    </div>
                    <!-- Aquarius -->
                    <div class="flex flex-col items-center zodiac-member" data-sign="aquarius">
                        <img src="https://placehold.co/100x100/00bfff/ffffff?text=Aquarius" alt="Aquarius" class="avatar w-20 h-20 zodiac-avatar">
                        <p class="mt-2 font-semibold text-sm">Aquarius</p>
                        <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                    </div>
                    <!-- Pisces -->
                    <div class="flex flex-col items-center zodiac-member" data-sign="pisces">
                        <img src="https://placehold.co/100x100/4169e1/ffffff?text=Pisces" alt="Pisces" class="avatar w-20 h-20 zodiac-avatar">
                        <p class="mt-2 font-semibold text-sm">Pisces</p>
                        <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                    </div>
                </div>
            </div>

            <div class="card admin-only" id="beats-admin-panel">
                <h2 class="text-xl font-bold mb-2">üéõÔ∏è Beat Manager</h2>
                <p class="text-xs text-gray-400 mb-3">Paste or edit beats JSON. Save to update the store instantly. This is stored in Firestore and overrides beats.json.</p>
                <textarea id="beats-admin-json" class="w-full bg-gray-800 text-xs text-white p-3 rounded-lg border border-gray-700" rows="10" placeholder='{"beats": [{"name": "SBM BEAT 5", "price": 100, "buyUrl": "https://...", "fileUrl": "/assets/SBM BEAT 5.mp4"}]}'></textarea>
                <div class="flex gap-2 mt-3">
                    <button id="beats-admin-load" class="bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-2 px-3 rounded">Load Current Beats</button>
                    <button id="beats-admin-save" class="bg-emerald-600 hover:bg-emerald-700 text-white text-xs font-bold py-2 px-3 rounded">Save Beats</button>
                </div>
                <p id="beats-admin-status" class="text-xs text-gray-400 mt-2"></p>
            </div>

            <!-- Hidden file input for image uploads -->
            <label for="admin-image-upload" class="sr-only">Upload zodiac image</label>
            <input type="file" id="admin-image-upload" accept="image/*" class="hidden" title="Upload zodiac image" aria-label="Upload zodiac image">


            <div id="studio-section">
                <div class="card">
                    <h2 class="text-2xl font-bold mb-4">AI ANTONIOS INTELIGENCE</h2>
                    <h3 class="text-lg text-gray-400">The AI Twin Pisces Ghost</h3>
                    <div class="mt-4">
                        <p id="beat-name" class="text-sm text-gray-400 mb-2">Now Playing: Not Loaded</p>
                        <video id="customPlayer" class="video-js vjs-default-skin w-full rounded-xl" controls preload="auto" data-setup='{}'></video>
                    </div>
                </div>

                <!-- GoodDGirl Waiting to Enter Section -->
                <div id="baddgirl-status-section" class="bad-d-girl-status">
                    <img id="baddgirl-avatar" class="avatar" src="https://placehold.co/150x150/7c3aed/ffffff?text=BadDGirl" alt="BadDGirl's Avatar">
                    <p class="mt-2 text-xl font-bold">GoodDGirl</p>
                    <span id="baddgirl-status" class="badge status-waiting">Waiting to Enter...</span>
                    <button id="approve-baddgirl-btn" class="mt-4 bg-lime-500 hover:bg-lime-600 text-white font-bold py-2 px-4 rounded-lg">
                        Approve GoodDGirl
                    </button>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- File Uploads and Master Purchase Section -->
                    <div class="card">
                        <h2 class="text-2xl font-bold mb-4">Record & Master</h2>
                        <div class="flex space-x-2 mt-4">
                            <button id="record-btn" class="flex-1 bg-red-600 hover:bg-red-700">Record</button>
                            <button id="stop-record-btn" class="flex-1 bg-gray-500 hover:bg-gray-600" disabled>Stop</button>
                        </div>
                        <div id="recording-playback" class="hidden mt-4">
                            <h3 class="text-md font-bold mb-2">Your Recording</h3>
                            <audio id="recording-player" controls class="w-full"></audio>
                            <a id="save-recording-btn" class="mt-2 block w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg" download="my-recording.webm">Save Recording</a>
                        </div>
                        <div class="file-upload-container">
                            <label for="beat-upload">Upload Beat (Audio/Video)</label>
                            <input type="file" id="beat-upload" accept="audio/*,video/mp4" class="hidden">
                        </div>
                        <p class="my-4 text-sm text-gray-300">Purchase the final master for distribution:</p>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
                            <button id="purchase-mp3-wav" class="bg-purple-600 hover:bg-purple-700">Buy Master MP3/WAV</button>
                            <button id="purchase-mp4" class="bg-pink-600 hover:bg-pink-700">Buy Master MP4 (Subscription)</button>
                        </div>
                        <img id="raydiant-seal" src="assets/AIclone.jpg" alt="AI Certified SBM Seal" class="w-24 h-24 mx-auto mt-4" />
                    </div>
                </div>

                <p id="rhyme-guidance" class="card mt-6 text-lg text-gray-300">
                    Your creative energy is now aligned. Alter your rhymes to benefit the people, with the spirit of your sign.
                </p>

                <!-- Chat Room for AI Correction -->
                <div id="chatroom-section" class="card">
                    <h2 class="text-2xl font-bold mb-4">"The Raydiant War" (The AI Twin)</h2>
                    <div class="chat-container mb-4" id="messages-display">
                        <!-- Chat messages will be rendered here -->
                    </div>
                    <form id="chat-form" class="flex space-x-2">
                        <input type="text" id="chat-input" placeholder="Drop your rhyme here..." class="flex-grow p-3 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-700">
                        <button id="generate-rhyme-btn" type="button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg">‚ú® Generate Rhyme</button>
                        <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Send</button>
                    </form>
                </div>
            </div>
            </div>

            <!-- Zodiac Council Page -->
            <div class="page-content hidden" id="page-zodiac">
                <div id="zodiac-section" class="card">
                    <h2 class="text-2xl font-bold mb-4 text-center">The Zodiac Council</h2>
                    <button class="toggle-admin-btn mb-4 bg-orange-600 hover:bg-orange-700 text-white font-bold py-1 px-3 rounded text-sm">üîì Admin Mode</button>
                    <div class="grid grid-cols-3 sm:grid-cols-4 gap-4 text-center">
                        <!-- Aries -->
                        <div class="flex flex-col items-center zodiac-member" data-sign="aries">
                            <img src="https://placehold.co/100x100/ff4500/ffffff?text=Aries" alt="Aries" class="avatar w-20 h-20 zodiac-avatar">
                            <p class="mt-2 font-semibold text-sm">Aries</p>
                            <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                        </div>
                        <!-- Taurus -->
                        <div class="flex flex-col items-center zodiac-member" data-sign="taurus">
                            <img src="https://placehold.co/100x100/228B22/ffffff?text=Taurus" alt="Taurus" class="avatar w-20 h-20 zodiac-avatar">
                            <p class="mt-2 font-semibold text-sm">Taurus</p>
                            <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                        </div>
                        <!-- Gemini -->
                        <div class="flex flex-col items-center zodiac-member" data-sign="gemini">
                            <img src="https://placehold.co/100x100/ffd700/ffffff?text=Gemini" alt="Gemini" class="avatar w-20 h-20 zodiac-avatar">
                            <p class="mt-2 font-semibold text-sm">Gemini</p>
                            <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                        </div>
                        <!-- Cancer -->
                        <div class="flex flex-col items-center zodiac-member" data-sign="cancer">
                            <img src="https://placehold.co/100x100/c0c0c0/ffffff?text=Cancer" alt="Cancer" class="avatar w-20 h-20 zodiac-avatar">
                            <p class="mt-2 font-semibold text-sm">Cancer</p>
                            <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                        </div>
                        <!-- Leo -->
                        <div class="flex flex-col items-center zodiac-member" data-sign="leo">
                            <img src="https://placehold.co/100x100/ff8c00/ffffff?text=Leo" alt="Leo" class="avatar w-20 h-20 zodiac-avatar">
                            <p class="mt-2 font-semibold text-sm">Leo</p>
                            <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                        </div>
                        <!-- Virgo -->
                        <div class="flex flex-col items-center zodiac-member" data-sign="virgo">
                            <img src="https://placehold.co/100x100/9acd32/ffffff?text=Virgo" alt="Virgo" class="avatar w-20 h-20 zodiac-avatar">
                            <p class="mt-2 font-semibold text-sm">Virgo</p>
                            <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                        </div>
                        <!-- Libra -->
                        <div class="flex flex-col items-center zodiac-member" data-sign="libra">
                            <img src="https://placehold.co/100x100/ff69b4/ffffff?text=Libra" alt="Libra" class="avatar w-20 h-20 zodiac-avatar">
                            <p class="mt-2 font-semibold text-sm">Libra</p>
                            <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                        </div>
                        <!-- Scorpio -->
                        <div class="flex flex-col items-center zodiac-member" data-sign="scorpio">
                            <img src="https://placehold.co/100x100/800000/ffffff?text=Scorpio" alt="Scorpio" class="avatar w-20 h-20 zodiac-avatar">
                            <p class="mt-2 font-semibold text-sm">Scorpio</p>
                            <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                        </div>
                        <!-- Sagittarius -->
                        <div class="flex flex-col items-center zodiac-member" data-sign="sagittarius">
                            <img src="https://placehold.co/100x100/4b0082/ffffff?text=Sagittarius" alt="Sagittarius" class="avatar w-20 h-20 zodiac-avatar">
                            <p class="mt-2 font-semibold text-sm">Sagittarius</p>
                            <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                        </div>
                        <!-- Capricorn -->
                        <div class="flex flex-col items-center zodiac-member" data-sign="capricorn">
                            <img src="https://placehold.co/100x100/696969/ffffff?text=Capricorn" alt="Capricorn" class="avatar w-20 h-20 zodiac-avatar">
                            <p class="mt-2 font-semibold text-sm">Capricorn</p>
                            <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                        </div>
                        <!-- Aquarius -->
                        <div class="flex flex-col items-center zodiac-member" data-sign="aquarius">
                            <img src="https://placehold.co/100x100/00bfff/ffffff?text=Aquarius" alt="Aquarius" class="avatar w-20 h-20 zodiac-avatar">
                            <p class="mt-2 font-semibold text-sm">Aquarius</p>
                            <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                        </div>
                        <!-- Pisces -->
                        <div class="flex flex-col items-center zodiac-member" data-sign="pisces">
                            <img src="https://placehold.co/100x100/4169e1/ffffff?text=Pisces" alt="Pisces" class="avatar w-20 h-20 zodiac-avatar">
                            <p class="mt-2 font-semibold text-sm">Pisces</p>
                            <button class="change-zodiac-btn admin-only text-xs mt-1 p-1 rounded bg-orange-500 hover:bg-orange-600">üì∑</button>
                        </div>
                    </div>

                </div>
            </div>

            <!-- Online Users Page -->
            <div class="page-content hidden" id="page-online">
                <div class="card">
                    <h2 class="text-lg font-bold mb-4 text-center">üü¢ Online Users</h2>
                    <p id="online-current-account" class="text-xs text-gray-400 mb-2">Current account: Checking‚Ä¶</p>
                    <p id="online-call-lock-note" class="text-xs text-amber-300 mb-3 hidden">üîê Calling is available after Google or email sign-in.</p>
                    <p id="online-call-unlocked-note" class="text-xs text-emerald-300 mb-3 hidden">‚úÖ Calling unlocked</p>
                    <div id="online-users-list" class="space-y-2">
                        <p class="text-gray-400 text-sm">Loading...</p>
                    </div>
                    <div id="call-status" class="text-xs text-yellow-400 mt-4 mb-2"></div>
                    <button id="hangup-call-btn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded mt-4 hidden">üìû Hang Up</button>
                </div>
            </div>

            <!-- Chat Page -->
            <div class="page-content hidden" id="page-chat">
                <div class="card page-chat-card">
                    <h2 class="text-lg font-bold mb-4 text-center">üí¨ Studio Chat</h2>
                    <div id="floating-chat-messages" class="floating-chat-messages floating-chat-messages-panel overflow-y-auto p-3 bg-gray-800 rounded mb-3 flex-1">
                        <p class="text-gray-400 text-xs">Loading messages...</p>
                    </div>
                    <div class="floating-chat-input-row flex gap-2">
                        <input type="text" id="floating-chat-input" class="floating-chat-input floating-chat-input-custom flex-1" placeholder="Say something..." maxlength="200">
                        <button id="floating-chat-send" class="floating-chat-send-btn">Send</button>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Message Box -->
    <div id="message-box" class="message-box">
        <p id="message-text"></p>
        <button id="close-message" class="mt-4 px-4 py-2 rounded-lg bg-purple-600">OK</button>
    </div>

    <!-- Giftbox Modal -->
    <div id="giftbox-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
        <div class="bg-gray-900 rounded-lg p-6 max-w-2xl w-full mx-4 max-h-screen overflow-y-auto border-2 border-yellow-500">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-yellow-400">üéÅ Gift Box</h2>
                <button id="close-giftbox-modal" class="text-white text-2xl hover:text-red-500">‚úï</button>
            </div>
            
            <div id="gift-recipient-display" class="hidden mb-4 p-3 bg-gray-800 rounded-lg border border-yellow-500">
                <p class="text-sm text-gray-300">Sending gift to: <span id="gift-recipient-name" class="text-yellow-400 font-bold"></span></p>
            </div>
            
            <div id="gifts-container" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- Gift cards will be generated here by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Balance Purchase Modal -->
    <div id="balance-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
        <div class="bg-gray-900 rounded-lg p-6 max-w-md w-full mx-4 border-2 border-yellow-500 balance-modal-panel">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-yellow-400">üí≥ Buy Balance</h2>
                <button id="close-balance-modal" class="text-white text-2xl hover:text-red-500">‚úï</button>
            </div>
            <p class="text-xs text-gray-400 mb-3">Select a USD bill to purchase credits. (1 credit = $1)</p>
            <div id="balance-options" class="grid grid-cols-1 gap-3">
                <!-- Balance options will be generated here by JavaScript -->
            </div>
            <div class="border-t border-gray-700 mt-4 pt-4">
                <h3 class="text-lg font-bold text-yellow-300 mb-2">üéµ Beat Downloads</h3>
                <p class="text-xs text-gray-400 mb-3">Purchase a beat, then download the file and license below.</p>
                <div id="beat-options" class="grid grid-cols-1 gap-3">
                    <!-- Beat options will be generated here by JavaScript -->
                </div>
            </div>
            <div class="border-t border-gray-700 mt-4 pt-4">
                <h3 class="text-lg font-bold text-yellow-300 mb-2">üëß Children's Song</h3>
                <p class="text-xs text-gray-400 mb-3">$50 MP4 download with license.</p>
                <div id="kids-song-options" class="grid grid-cols-1 gap-3">
                    <!-- Kids song options will be generated here by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <!-- Gift Animation Overlay -->
    <div id="gift-animation" class="fixed inset-0 pointer-events-none hidden z-40">
        <div id="gift-emoji-container" class="absolute inset-0"></div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, setPersistence, browserSessionPersistence, signInAnonymously, signInWithCustomToken, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, signInWithPopup, signInWithRedirect, getRedirectResult, GoogleAuthProvider } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, initializeFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, addDoc, serverTimestamp, query, orderBy, limit, where, getDocs, deleteField, increment } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        setLogLevel('error');
        // Debug logger (toggle with DEBUG_VERBOSE, also routes to on-screen panel)
        const DEBUG_VERBOSE = window.localStorage.DEBUG_VERBOSE === '1';
        function dlog(...args) {
            if (DEBUG_VERBOSE) {
                const msg = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
                appendDebugPanel(msg);
                console.debug('[DEBUG]', ...args);
            }
        }

        function setupDebugPanel() {
            const panel = document.getElementById('debug-panel');
            if (DEBUG_VERBOSE) {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        function appendDebugPanel(msg) {
            const panel = document.getElementById('debug-panel');
            if (!panel || !DEBUG_VERBOSE) return;
            const content = document.getElementById('debug-panel-content');
            const div = document.createElement('div');
            div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            content.appendChild(div);
            // Keep only last 50 messages
            while (content.childNodes.length > 50) content.removeChild(content.firstChild);
            // Scroll to bottom
            content.scrollTop = content.scrollHeight;
        }

        function clearDebugPanel() {
            const content = document.getElementById('debug-panel-content');
            if (content) content.innerHTML = '';
        }

        <!-- On-screen debug panel (hidden by default, toggled by DEBUG_VERBOSE) -->
        <div id="debug-panel" style="display:none; position:fixed; bottom:0; right:0; width:340px; max-height:40vh; overflow:auto; background:rgba(20,20,20,0.95); color:#fff; font-size:13px; z-index:9999; border-radius:8px 8px 0 0; box-shadow:0 0 8px #000; padding:8px 12px 8px 8px; pointer-events:auto;">
            <div style="font-weight:bold; margin-bottom:4px;">Debug Panel <button onclick="clearDebugPanel()" style='float:right; background:none; border:none; color:#fff; font-size:12px; cursor:pointer;'>‚úï</button></div>
            <div id="debug-panel-content"></div>
        </div>
        // Global Firebase variables
        let firebaseConfig = typeof window.__firebase_config !== 'undefined' ? window.__firebase_config : {};
        if (typeof firebaseConfig === 'string') {
            try {
                firebaseConfig = JSON.parse(firebaseConfig);
            } catch (e) {
                console.warn('Invalid __firebase_config JSON string:', e);
                firebaseConfig = {};
            }
        }
        let appId = firebaseConfig.projectId || (typeof window.__app_id !== 'undefined' ? window.__app_id : 'raydent-app');
        const initialAuthToken = typeof window.__initial_auth_token !== 'undefined' ? window.__initial_auth_token : null;
        
        let db, auth;
        let userId;
        let localStream; // To hold the camera stream

        // Recording variables
        let mediaRecorder;
        let audioChunks = [];
        let audioBlob;

        // Utility function to show a custom message box instead of alert()
        function showMessage(message) {
            document.getElementById('message-text').textContent = message;
            document.getElementById('message-box').style.display = 'block';
        }

        async function resolveFirebaseConfig() {
            if (typeof firebaseConfig === 'string') {
                try {
                    firebaseConfig = JSON.parse(firebaseConfig);
                } catch (e) {
                    console.warn('Invalid __firebase_config JSON string:', e);
                    firebaseConfig = {};
                }
            }
            if (Object.keys(firebaseConfig).length) return firebaseConfig;
            try {
                const res = await fetch('/__/firebase/init.json');
                if (res.ok) {
                    firebaseConfig = await res.json();
                }
            } catch (e) {
                console.warn('Failed to load Firebase Hosting config:', e);
            }
            return firebaseConfig;
        }

        let callingUnlocked = false;

        function isCallingEligibleUser(user) {
            if (!user) return false;
            if (user.isAnonymous) return false;
            if (user.email) return true;
            const providers = Array.isArray(user.providerData) ? user.providerData : [];
            return providers.some(p => p && p.providerId && p.providerId !== 'anonymous');
        }

        function updateAuthUI(user) {
            const authStatus = document.getElementById('auth-status');
            const signInBtn = document.getElementById('sign-in-btn');
            const signUpBtn = document.getElementById('sign-up-btn');
            const signOutBtn = document.getElementById('sign-out-btn');
            const onlineCallLockNote = document.getElementById('online-call-lock-note');
            const onlineCallUnlockedNote = document.getElementById('online-call-unlocked-note');
            const onlineCurrentAccount = document.getElementById('online-current-account');
            if (!authStatus || !signInBtn || !signUpBtn || !signOutBtn) return;
            callingUnlocked = isCallingEligibleUser(user);
            const copyEmailBtnHome = document.getElementById('copy-email-btn-home');
            const copyEmailBtn = document.getElementById('copy-email-btn');
            if (user && user.email) {
                authStatus.textContent = `Signed in as ${user.email}`;
                signInBtn.disabled = true;
                signUpBtn.disabled = true;
                signOutBtn.disabled = false;
                if (copyEmailBtnHome) copyEmailBtnHome.disabled = false;
                if (copyEmailBtn) copyEmailBtn.disabled = false;
                if (onlineCallLockNote) onlineCallLockNote.classList.add('hidden');
                if (onlineCallUnlockedNote) onlineCallUnlockedNote.classList.remove('hidden');
                if (onlineCurrentAccount) onlineCurrentAccount.textContent = `Current account: ${user.email}`;
            } else if (user) {
                authStatus.textContent = 'Signed in (anonymous)';
                signInBtn.disabled = false;
                signUpBtn.disabled = false;
                signOutBtn.disabled = false;
                if (copyEmailBtnHome) copyEmailBtnHome.disabled = true;
                if (copyEmailBtn) copyEmailBtn.disabled = true;
                if (onlineCallLockNote) onlineCallLockNote.classList.remove('hidden');
                if (onlineCallUnlockedNote) onlineCallUnlockedNote.classList.add('hidden');
                if (onlineCurrentAccount) onlineCurrentAccount.textContent = 'Current account: Anonymous (sign in required for calls)';
            } else {
                authStatus.textContent = 'Signed out';
                signInBtn.disabled = false;
                signUpBtn.disabled = false;
                signOutBtn.disabled = true;
                if (copyEmailBtnHome) copyEmailBtnHome.disabled = true;
                if (copyEmailBtn) copyEmailBtn.disabled = true;
                if (onlineCallLockNote) onlineCallLockNote.classList.remove('hidden');
                if (onlineCallUnlockedNote) onlineCallUnlockedNote.classList.add('hidden');
                if (onlineCurrentAccount) onlineCurrentAccount.textContent = 'Current account: Signed out';
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            let autoGoLiveEnabled = false;
            let selectedMicDeviceId = '';

            const safeStorageGet = (key, fallback = '') => {
                try {
                    const value = localStorage.getItem(key);
                    return value ?? fallback;
                } catch (e) {
                    return fallback;
                }
            };

            const safeStorageSet = (key, value) => {
                try {
                    localStorage.setItem(key, value);
                } catch (e) {}
            };

            autoGoLiveEnabled = safeStorageGet('autoGoLiveHost', 'false') === 'true';
            selectedMicDeviceId = safeStorageGet('preferredMicDeviceId', '') || '';
            // Get elements
            const userAvatar = document.getElementById('user-avatar');
            const generateAvatarBtn = document.getElementById('generate-avatar-btn');
            const appContent = document.getElementById('app-content');
            const userIdDisplay = document.getElementById('user-id-display');
            const localVideo = document.getElementById('localVideo');
            const broadcastVideo = document.getElementById('broadcast-video');
            const customPlayer = window.videojs ? videojs('customPlayer') : null;
            const purchaseBeatBtn = document.getElementById('purchase-beat-btn');
            const beatNameDisplay = document.getElementById('beat-name');
            const messagesDisplay = document.getElementById('messages-display');
            const chatForm = document.getElementById('chat-form');
            const chatInput = document.getElementById('chat-input');
            const generateRhymeBtn = document.getElementById('generate-rhyme-btn');
            const baddgirlStatus = document.getElementById('baddgirl-status');
            const approveBaddgirlBtn = document.getElementById('approve-baddgirl-btn');
            const recordBtn = document.getElementById('record-btn');
            const stopRecordBtn = document.getElementById('stop-record-btn');
            const recordingPlayback = document.getElementById('recording-playback');
            const recordingPlayer = document.getElementById('recording-player');
            const saveRecordingBtn = document.getElementById('save-recording-btn');
            const onlineUsersList = document.getElementById('online-users-list');
            const callStatus = document.getElementById('call-status');
            const hangupCallBtn = document.getElementById('hangup-call-btn');
            const callIdInput = document.getElementById('call-id-input');
            const callIdDisplay = document.getElementById('call-id-display');
            const localCallVideo = document.getElementById('local-call-video');
            const remoteCallVideo = document.getElementById('remote-call-video');
            const sidebar = document.querySelector('.sidebar');
            const sidebarToggleBtn = document.getElementById('sidebar-toggle-btn');
            const shareAppBtn = document.getElementById('share-app-btn');
            const goLiveBtn = document.getElementById('go-live-btn');
            const endLiveBtn = document.getElementById('end-live-btn');
            const broadcastStatus = document.getElementById('broadcast-status');
            const micToggleBtn = document.getElementById('mic-toggle-btn');
            const monitorToggleBtn = document.getElementById('monitor-toggle-btn');
            const hostModeBtn = document.getElementById('host-mode-btn');
            const micSelect = document.getElementById('mic-select');
            const micMonitor = document.getElementById('mic-monitor');
            const enableCameraBtn = document.getElementById('enable-camera-btn');

            // Add playsinline attribute for browsers that support it
            if (remoteCallVideo && 'playsInline' in remoteCallVideo) {
                remoteCallVideo.setAttribute('playsinline', '');
            }

            if (goLiveBtn) {
                goLiveBtn.style.display = 'inline-flex';
                goLiveBtn.disabled = false;
            }
            if (endLiveBtn) {
                endLiveBtn.style.display = 'none';
            }
            const ensureCameraControlsVisible = () => {
                const cameraControls = document.getElementById('camera-controls');
                if (cameraControls) {
                    cameraControls.style.display = 'flex';
                    cameraControls.style.visibility = 'visible';
                    cameraControls.style.opacity = '1';
                }

                const forceVisible = [
                    'buy-balance-btn-camera',
                    'go-live-btn',
                    'end-live-btn',
                    'mic-toggle-btn',
                    'monitor-toggle-btn',
                    'mic-select',
                    'host-mode-btn',
                    'enable-camera-btn'
                ];

                forceVisible.forEach(id => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    if (id === 'end-live-btn') {
                        el.style.display = 'none';
                    } else if (el.tagName === 'SELECT') {
                        el.style.display = 'inline-flex';
                    } else {
                        el.style.display = 'inline-flex';
                    }
                    el.style.visibility = 'visible';
                    el.style.opacity = '1';
                });
            };
            ensureCameraControlsVisible();
            setTimeout(ensureCameraControlsVisible, 1500);
            updateHostModeUI();
            populateMicDevices();

            // Auth elements
            const authEmailInput = document.getElementById('auth-email');
            const authPasswordInput = document.getElementById('auth-password');
            const signUpBtn = document.getElementById('sign-up-btn');
            const signInBtn = document.getElementById('sign-in-btn');
            const signOutBtn = document.getElementById('sign-out-btn');
            const authStatus = document.getElementById('auth-status');
            const appHostDisplay = document.getElementById('app-host-display');
            const appHostDisplayCamera = document.getElementById('app-host-display-camera');
            const currentOrigin = window.location.origin;
            const currentHref = window.location.href;
            if (appHostDisplay) {
                appHostDisplay.textContent = currentOrigin;
                appHostDisplay.title = currentHref;
                appHostDisplay.style.cursor = 'pointer';
            }
            if (appHostDisplayCamera) {
                appHostDisplayCamera.textContent = currentOrigin;
                appHostDisplayCamera.title = currentHref;
                appHostDisplayCamera.style.cursor = 'pointer';
            }

            const attachCopyHostHandler = (element) => {
                if (!element) return;
                element.addEventListener('click', async () => {
                    try {
                        await navigator.clipboard.writeText(currentOrigin);
                        showMessage(`Copied host URL: ${currentOrigin}`);
                    } catch (error) {
                        showMessage(`Host URL: ${currentOrigin}`);
                    }
                });
            };
            attachCopyHostHandler(appHostDisplay);
            attachCopyHostHandler(appHostDisplayCamera);
            
            // Balance and Gift Box elements
            const balanceHomeDisplay = document.getElementById('balance-home');
            const balanceAccountDisplay = document.getElementById('balance-account');
            const buyBalanceBtnHome = document.getElementById('buy-balance-btn-home');
            const buyBalanceBtnAccount = document.getElementById('buy-balance-btn-account');
            const buyBalanceBtnCamera = document.getElementById('buy-balance-btn-camera');
            const giftboxIconHome = document.getElementById('giftbox-icon-home');
            const giftboxModal = document.getElementById('giftbox-modal');
            const giftsContainer = document.getElementById('gifts-container');
            const closeGiftboxModal = document.getElementById('close-giftbox-modal');
            const giftAnimation = document.getElementById('gift-animation');
            const giftEmojiContainer = document.getElementById('gift-emoji-container');
            const balanceModal = document.getElementById('balance-modal');
            const balanceOptions = document.getElementById('balance-options');
            const closeBalanceModal = document.getElementById('close-balance-modal');
            const beatOptions = document.getElementById('beat-options');
            const kidsSongOptions = document.getElementById('kids-song-options');
            const beatStoreGrid = document.getElementById('beat-store-grid');
            
            // Gift definitions with costs (in credits) - using beat videos as placeholders
            const GIFTS = [
                { id: 'rose-box', name: 'üåπ Rose Box', cost: 5, emoji: 'üåπ' },
                { id: 'flower-bouquet', name: 'üíê Flower Bouquet', cost: 3, emoji: 'üíê' },
                { id: 'teddy-love', name: 'üß∏ Teddy Love', cost: 4, emoji: 'üß∏' },
                { id: 'star-shower', name: '‚ú® Star Shower', cost: 6, emoji: '‚ú®' },
                { id: 'crown', name: 'üëë Crown', cost: 8, emoji: 'üëë' },
                { id: 'heart-burst', name: 'üíñ Heart Burst', cost: 2, emoji: 'üíñ' }
            ];
            
            // Balance purchase links (Stripe) - USD bill icons
            const BALANCE_PACKAGES = [
                { credits: 5, price: 5, icon: 'üíµ', label: '$5 Bill', url: 'https://buy.stripe.com/dRm14ndNHbQagre1Vg7EQ0M' },
                { credits: 10, price: 10, icon: 'üíµ', label: '$10 Bill', url: 'https://buy.stripe.com/14A00j24Z8DY0sg8jE7EQ0O' },
                { credits: 20, price: 20, icon: 'üíµ', label: '$20 Bill', url: 'https://buy.stripe.com/eVqeVd10V4nI7UIbvQ7EQ0P' },
                { credits: 100, price: 100, icon: 'üíµ', label: '$100 Bill', url: 'https://buy.stripe.com/cNi9ATeRL2fA5MA2Zk7EQ0J' }
            ];

            let BEAT_PACKAGES = [];

            // Load beats from Firestore (admin-managed) with JSON fallback
            async function loadBeats() {
                let beats = [];

                if (db && appId) {
                    try {
                        // Correct path: artifacts/{appId}/public/data document with beats field
                        const beatsDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data'));
                        if (beatsDoc.exists()) {
                            const data = beatsDoc.data() || {};
                            beats = Array.isArray(data.beats) ? data.beats : [];
                        }
                    } catch (error) {
                        console.warn('Error loading beats from Firestore:', error);
                    }
                }

                if (!beats.length) {
                    try {
                        const response = await fetch('/assets/beats.json');
                        const data = await response.json();
                        beats = data.beats || [];
                    } catch (error) {
                        console.error('Error loading beats.json:', error);
                        beats = [];
                    }
                }

                BEAT_PACKAGES = beats;
                console.log('Loaded beats:', BEAT_PACKAGES);
                buildBeatOptions();

                const beatsAdminText = document.getElementById('beats-admin-json');
                if (beatsAdminText) {
                    beatsAdminText.value = JSON.stringify({ beats: BEAT_PACKAGES }, null, 2);
                }
            }

            async function saveBeatsToFirestore(beats) {
                if (!db || !appId) return false;
                await setDoc(
                    doc(db, 'artifacts', appId, 'public', 'beats', 'data', 'list'),
                    { beats, updatedAt: serverTimestamp() },
                    { merge: true }
                );
                return true;
            }

            const KIDS_SONG_PACKAGES = [
                {
                    name: 'Respect and Honesty (Childrens Song)',
                    price: 50,
                    buyUrl: 'https://buy.stripe.com/cNibJ19xr6vQ5MAgQa7EQ0L',
                    fileUrl: '/assets/worldwide mafia GOODFELLAHZ entertainment.mp4'
                }
            ];
            
            const giftPurchaseBtns = document.querySelectorAll('.gift-purchase-btn');
            const giftRecipientForm = document.getElementById('gift-recipient-form');
            const giftRecipientEmail = document.getElementById('gift-recipient-email');
            const giftConfirmBtn = document.getElementById('gift-confirm-btn');
            const giftCount = document.getElementById('gift-count');
            const cameraGiftOverlay = document.getElementById('camera-gift-overlay');

            let selectedGift = null;
            let selectedGiftUser = null;
            let selectedGiftUserEmail = null;
            let giftsListenerReady = false;
            const processedGiftIds = new Set();

            // Admin elements
            const toggleAdminBtns = document.querySelectorAll('.toggle-admin-btn');
            const changeFirstLadyBtn = document.getElementById('change-first-lady-btn');
            const adminImageUpload = document.getElementById('admin-image-upload');
            const goodDGirlAvatar = document.getElementById('Good-D-Girl-avatar');
            let adminMode = false;
            let currentUploadTarget = null;

            // Page navigation
            function switchPage(pageName) {
                // Query fresh on each call
                const pageContents = document.querySelectorAll('.page-content');
                const pageNavBtns = document.querySelectorAll('.page-nav-btn');
                
                // Hide all pages
                pageContents.forEach(page => page.classList.add('hidden'));
                
                // Deactivate all nav buttons
                pageNavBtns.forEach(btn => btn.classList.remove('active'));
                
                // Show selected page
                const selectedPage = document.getElementById(`page-${pageName}`);
                if (selectedPage) {
                    selectedPage.classList.remove('hidden');
                }
                
                // Activate selected nav button
                const activeBtn = document.querySelector(`[data-page="${pageName}"]`);
                if (activeBtn) {
                    activeBtn.classList.add('active');
                }
            }

            // Page navigation event listeners (query fresh)
            const pageNavBtns = document.querySelectorAll('.page-nav-btn');
            pageNavBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const page = btn.getAttribute('data-page');
                    switchPage(page);
                });
            });

            // Sidebar toggle (open/close)
            if (sidebarToggleBtn && sidebar) {
                sidebarToggleBtn.style.display = 'inline-flex';
                sidebarToggleBtn.addEventListener('click', () => {
                    const isCollapsed = sidebar.classList.toggle('collapsed');
                    sidebarToggleBtn.textContent = isCollapsed ? '‚û°Ô∏è' : '‚¨ÖÔ∏è';
                    sidebarToggleBtn.setAttribute('aria-label', isCollapsed ? 'Open sidebar' : 'Close sidebar');
                });
            }

            // Share app
            if (shareAppBtn) {
                shareAppBtn.addEventListener('click', async () => {
                    const shareData = {
                        title: 'AI ANTONIOS INTELLIGENCE',
                        text: 'Check out AI ANTONIOS INTELLIGENCE',
                        url: window.location.href
                    };
                    try {
                        if (navigator.share) {
                            await navigator.share(shareData);
                        } else if (navigator.clipboard) {
                            await navigator.clipboard.writeText(shareData.url);
                            showMessage('Link copied to clipboard.');
                        } else {
                            showMessage(`Share this link: ${shareData.url}`);
                        }
                    } catch (error) {
                        console.error('Share failed:', error);
                        showMessage('Unable to share.');
                    }
                });
            }

            if (goLiveBtn) {
                goLiveBtn.addEventListener('click', () => {
                    startBroadcast();
                    autoGoLiveEnabled = true;
                    safeStorageSet('autoGoLiveHost', 'true');
                    updateHostModeUI();
                });
            }

            if (endLiveBtn) {
                endLiveBtn.addEventListener('click', () => {
                    endBroadcast();
                });
            }

            if (micToggleBtn) {
                micToggleBtn.addEventListener('click', () => {
                    setMicEnabled(!micEnabled);
                });
            }

            if (monitorToggleBtn) {
                monitorToggleBtn.addEventListener('click', () => {
                    setMonitorEnabled(!monitorEnabled);
                });
            }

            if (enableCameraBtn) {
                enableCameraBtn.addEventListener('click', () => {
                    startCamera(true);
                });
            }

            if (hostModeBtn) {
                hostModeBtn.addEventListener('click', () => {
                    autoGoLiveEnabled = !autoGoLiveEnabled;
                    safeStorageSet('autoGoLiveHost', autoGoLiveEnabled ? 'true' : 'false');
                    updateHostModeUI();
                });
            }

            if (micSelect) {
                micSelect.addEventListener('change', () => {
                    selectedMicDeviceId = micSelect.value;
                    safeStorageSet('preferredMicDeviceId', selectedMicDeviceId);
                });
            }

            // Close message box
            document.getElementById('close-message')?.addEventListener('click', () => {
                document.getElementById('message-box').style.display = 'none';
            });

            const rememberAuthReturnPage = (page) => {
                try {
                    sessionStorage.setItem('authReturnPage', page);
                } catch (e) {}
            };

            // === AUTH FUNCTIONS ===
            async function signUp() {
                const email = (document.getElementById('auth-email') || document.getElementById('auth-email-2'))?.value;
                const password = (document.getElementById('auth-password') || document.getElementById('auth-password-2'))?.value;
                if (!email || !password) {
                    showMessage('Please enter email and password');
                    return;
                }
                try {
                    await createUserWithEmailAndPassword(auth, email, password);
                    showMessage('Account created!');
                } catch (error) {
                    showMessage(`Error: ${error.message}`);
                }
            }

            async function signIn() {
                const email = (document.getElementById('auth-email') || document.getElementById('auth-email-2'))?.value;
                const password = (document.getElementById('auth-password') || document.getElementById('auth-password-2'))?.value;
                if (!email || !password) {
                    showMessage('Please enter email and password');
                    return;
                }
                try {
                    await signInWithEmailAndPassword(auth, email, password);
                    showMessage('Signed in!');
                } catch (error) {
                    showMessage(`Error: ${error.message}`);
                }
            }

            async function signOutUser() {
                try {
                    await signOut(auth);
                    autoGoLiveEnabled = false;
                    safeStorageSet('autoGoLiveHost', 'false');
                    updateHostModeUI();
                    showMessage('Signed out!');
                    switchPage('account');
                } catch (error) {
                    showMessage(`Error: ${error.message}`);
                }
            }

            // Auth button event listeners
            document.getElementById('sign-up-btn')?.addEventListener('click', () => { rememberAuthReturnPage('account'); signUp(); });
            document.getElementById('sign-up-btn-2')?.addEventListener('click', () => { rememberAuthReturnPage('account'); signUp(); });
            document.getElementById('sign-in-btn')?.addEventListener('click', () => { rememberAuthReturnPage('account'); signIn(); });
            document.getElementById('sign-in-btn-2')?.addEventListener('click', () => { rememberAuthReturnPage('account'); signIn(); });
            document.getElementById('sign-out-btn')?.addEventListener('click', signOutUser);
            document.getElementById('sign-out-btn-2')?.addEventListener('click', signOutUser);

            // Google sign in: popup first, redirect fallback when popup is blocked
            const startGoogleSignIn = async () => {
                const provider = new GoogleAuthProvider();
                provider.setCustomParameters({ prompt: 'select_account' });

                try {
                    const popupResult = await signInWithPopup(auth, provider);
                    if (popupResult?.user?.email) {
                        showMessage(`Google sign-in successful: ${popupResult.user.email}`);
                    } else {
                        showMessage('Google sign-in successful');
                    }
                    return { method: 'popup' };
                } catch (error) {
                    const fallbackToRedirectCodes = new Set([
                        'auth/popup-blocked',
                        'auth/operation-not-supported-in-this-environment'
                    ]);

                    if (!fallbackToRedirectCodes.has(error?.code)) {
                        throw error;
                    }

                    showMessage('Popup blocked. Continuing with Google redirect sign-in...');
                    await signInWithRedirect(auth, provider);
                    return { method: 'redirect' };
                }
            };

            const handleGoogleSignIn = async () => {
                rememberAuthReturnPage('account');
                try {
                    console.log('üîê Google sign-in initiated...');
                    const result = await startGoogleSignIn();
                    if (result?.method === 'redirect') {
                        console.log('‚Ü™Ô∏è Google redirect started');
                    } else {
                        console.log('‚úÖ Google popup sign-in completed');
                    }
                } catch (error) {
                    console.error('‚ùå Google sign-in error:', error);
                    console.error('Error code:', error.code);
                    console.error('Error message:', error.message);
                    if (error.code === 'auth/popup-closed-by-user' || error.code === 'auth/redirect-cancelled-by-user') {
                        showMessage('Google sign-in cancelled');
                    } else if (error.code === 'auth/operation-not-supported-in-this-environment') {
                        showMessage('Google sign-in not available. Use email/password instead.');
                    } else {
                        showMessage(`Sign-in error: ${error.message}`);
                    }
                }
            };

            document.getElementById('google-sign-in-btn-home')?.addEventListener('click', handleGoogleSignIn);
            document.getElementById('google-sign-in-btn')?.addEventListener('click', handleGoogleSignIn);

            // Copy email buttons
            document.getElementById('copy-email-btn-home')?.addEventListener('click', () => {
                const email = auth?.currentUser?.email;
                if (email) {
                    navigator.clipboard.writeText(email);
                    showMessage(`Copied: ${email}`);
                }
            });

            document.getElementById('copy-email-btn')?.addEventListener('click', () => {
                const email = auth?.currentUser?.email;
                if (email) {
                    navigator.clipboard.writeText(email);
                    showMessage(`Copied: ${email}`);
                }
            });

            // === ADMIN MODE FUNCTIONS ===
            async function toggleAdminMode() {
                const password = prompt('Enter admin password:');
                if (password === 'pisces2024') {
                    adminMode = !adminMode;
                    document.querySelectorAll('.toggle-admin-btn').forEach(btn => {
                        btn.textContent = adminMode ? 'üîì Admin' : 'üîí Admin';
                    });
                    showMessage(adminMode ? 'Admin mode ON' : 'Admin mode OFF');
                    updateAdminUI();
                } else {
                    showMessage('Incorrect password');
                }
            }

            function updateAdminUI() {
                const adminElements = document.querySelectorAll('.admin-only');
                adminElements.forEach(el => {
                    el.style.display = adminMode ? 'block' : 'none';
                });
            }

            function setBeatsAdminStatus(message, isError = false) {
                const status = document.getElementById('beats-admin-status');
                if (!status) return;
                status.textContent = message;
                status.style.color = isError ? '#ff6b6b' : '#9ae6b4';
            }

            // === PROFILE FUNCTIONALITY ===
            const userProfilePhoto = document.getElementById('user-profile-photo');
            const uploadProfilePhotoBtn = document.getElementById('upload-profile-photo-btn');
            const profilePhotoUpload = document.getElementById('profile-photo-upload');
            const userUsername = document.getElementById('user-username');
            const saveProfileBtn = document.getElementById('save-profile-btn');
            const profileStatus = document.getElementById('profile-status');

            let userProfile = { username: '', photoUrl: '' };

            async function loadUserProfile() {
                if (!db || !appId || !userId) {
                    console.warn('‚ö†Ô∏è loadUserProfile: Missing db, appId, or userId', { db: !!db, appId, userId });
                    return;
                }

                console.log('üìã Loading user profile for userId:', userId);
                let data = null;
                try {
                    const profileDoc = await getDoc(doc(db, 'artifacts', appId, 'users', userId, 'profile', 'data'));
                    if (profileDoc.exists()) {
                        data = profileDoc.data();
                        console.log('‚úÖ Found private profile:', data);
                    }
                } catch (error) {
                    console.warn('Private profile load failed:', error?.message || error);
                }

                if (!data) {
                    try {
                        const publicDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'profiles', userId));
                        if (publicDoc.exists()) {
                            data = publicDoc.data();
                            console.log('‚úÖ Found public profile:', data);
                        } else {
                            console.log('‚ùå No public profile found for userId:', userId);
                        }
                    } catch (error) {
                        console.warn('Public profile load failed:', error?.message || error);
                    }
                }

                if (data) {
                    userProfile.username = data.username || data.displayName || '';
                    userProfile.photoUrl = data.profilePhoto || data.photoUrl || '';
                    console.log('‚úÖ Profile loaded:', userProfile);

                    if (userUsername) userUsername.value = userProfile.username;
                    if (userProfile.photoUrl && userProfilePhoto) {
                        userProfilePhoto.src = userProfile.photoUrl;
                    }
                } else {
                    // Don't create a default username - let user set it
                    userProfile.username = '';
                    console.log('üìù Profile not found - user can create one by entering a username');
                    
                    if (userUsername) userUsername.value = '';
                }
                
                console.log('‚úÖ loadUserProfile() COMPLETED');
            }

            uploadProfilePhotoBtn?.addEventListener('click', () => {
                profilePhotoUpload?.click();
            });

            // Helper function to compress image to stay under Firestore's 1MB field limit
            async function compressImage(file, maxSizeKB = 400) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            let width = img.width;
                            let height = img.height;
                            
                            // Resize to max 300px on longest side (reduced from 500px)
                            const maxDim = 300;
                            if (width > height && width > maxDim) {
                                height = (height * maxDim) / width;
                                width = maxDim;
                            } else if (height > maxDim) {
                                width = (width * maxDim) / height;
                                height = maxDim;
                            }
                            
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            
                            // Try different quality levels to stay under limit
                            let quality = 0.7;
                            let dataURL = canvas.toDataURL('image/jpeg', quality);
                            
                            // Reduce quality if still too large (base64 is ~4/3 of binary size)
                            while (dataURL.length > maxSizeKB * 1024 * 1.37 && quality > 0.1) {
                                quality -= 0.1;
                                dataURL = canvas.toDataURL('image/jpeg', quality);
                            }
                            
                            const sizeKB = Math.round(dataURL.length / 1024);
                            console.log(`üì∏ Image compressed: ${width}x${height}, quality=${quality.toFixed(2)}, size=${sizeKB}KB`);
                            resolve(dataURL);
                        };
                        img.onerror = reject;
                        img.src = e.target.result;
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            profilePhotoUpload?.addEventListener('change', async (e) => {
                const file = e.target.files?.[0];
                if (!file) return;

                try {
                    const compressedDataURL = await compressImage(file);
                    if (userProfilePhoto) {
                        userProfilePhoto.src = compressedDataURL;
                    }
                    userProfile.photoUrl = compressedDataURL;
                    
                    // Immediately save photo to Firestore so it appears in chat/online users
                    if (userId && db && appId) {
                        try {
                            console.log('üíæ Saving photo to Firestore...');
                            // Save to private profile
                            await setDoc(
                                doc(db, 'artifacts', appId, 'users', userId, 'profile', 'data'),
                                { profilePhoto: compressedDataURL },
                                { merge: true }
                            );
                            console.log('‚úÖ Photo saved to private profile');
                            
                            // Save to public profile
                            await setDoc(
                                doc(db, 'artifacts', appId, 'public', 'data', 'profiles', userId),
                                { profilePhoto: compressedDataURL, updatedAt: serverTimestamp() },
                                { merge: true }
                            );
                            console.log('‚úÖ Photo saved to public profile');
                            
                            // Clear cache so next load gets fresh data
                            delete userProfileCache[userId];
                            
                            showMessage('‚úÖ Photo uploaded successfully!');
                        } catch (err) {
                            console.error('‚ùå Error saving photo to Firestore:', err);
                            console.error('Error code:', err.code);
                            console.error('Error message:', err.message);
                            if (err.message?.includes('maximum size') || err.code === 'invalid-argument') {
                                showMessage('Photo too large. Please use a smaller image (under 1MB).');
                            } else {
                                showMessage('Error uploading photo: ' + (err.message || 'Unknown error'));
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error compressing image:', error);
                    showMessage('Failed to process image. Please try another photo.');
                }
            });

            if (saveProfileBtn) {
                console.log('‚úÖ Save Profile button found, attaching listener...');
                saveProfileBtn.addEventListener('click', async () => {
                    console.log('üîò Save Profile button clicked!');
                    if (!userUsername || !userUsername.value.trim()) {
                        setProfileStatus('Please enter a username.', true);
                        return;
                    }

                // Validate Firebase initialization
                if (!db) {
                    setProfileStatus('Database not initialized. Please refresh.', true);
                    console.error('Profile save failed: db is not initialized');
                    return;
                }

                if (!userId) {
                    setProfileStatus('Not authenticated. Please wait or sign in.', true);
                    console.error('Profile save failed: userId is not set');
                    return;
                }

                if (!appId) {
                    setProfileStatus('App configuration missing. Please refresh.', true);
                    console.error('Profile save failed: appId is not set');
                    return;
                }

                userProfile.username = userUsername.value.trim();

                let saved = false;
                try {
                    console.log('üíæ Saving to private profile...');
                    await setDoc(
                        doc(db, 'artifacts', appId, 'users', userId, 'profile', 'data'),
                        {
                            username: userProfile.username,
                            profilePhoto: userProfile.photoUrl
                        },
                        { merge: true }
                    );
                    console.log('‚úÖ Private profile saved');
                    saved = true;
                } catch (error) {
                    console.error('‚ùå Private profile save failed:', error);
                    console.error('Error code:', error.code);
                    console.error('Error message:', error.message);
                    if (error?.message?.includes('maximum size') || error.code === 'invalid-argument') {
                        setProfileStatus('Photo too large. Try a smaller image.', true);
                        return;
                    }
                }

                try {
                    console.log('üíæ Saving to public profile...');
                    await setDoc(
                        doc(db, 'artifacts', appId, 'public', 'data', 'profiles', userId),
                        {
                            username: userProfile.username,
                            profilePhoto: userProfile.photoUrl,
                            userId,
                            updatedAt: serverTimestamp()
                        },
                        { merge: true }
                    );
                    console.log('‚úÖ Public profile saved');
                    saved = true;
                } catch (error) {
                    console.error('‚ùå Public profile save failed:', error);
                    console.error('Error code:', error.code);
                    console.error('Error message:', error.message);
                    if (error?.message?.includes('maximum size') || error.code === 'invalid-argument') {
                        setProfileStatus('Photo too large. Try a smaller image.', true);
                        return;
                    }
                }

                if (saved) {
                    setProfileStatus('‚úÖ Profile saved successfully!', false);
                    alert(`‚úÖ Profile saved!\nUsername: ${userProfile.username}`);
                    console.log('üìù Profile saved with username:', userProfile.username);
                    console.log('üì∏ Profile saved with photo size:', userProfile.photoUrl?.length || 0, 'bytes');
                    
                    // Also update presence with new username
                    if (userId && db && appId) {
                        try {
                            await updateDoc(doc(db, 'artifacts', appId, 'presence', userId), {
                                username: userProfile.username
                            });
                            console.log('‚úÖ Updated presence with new username:', userProfile.username);
                            // Clear the profile cache so it will be reloaded with new data
                            delete userProfileCache[userId];
                            console.log('üóëÔ∏è Cleared profile cache');
                        } catch (err) {
                            console.warn('Could not update presence with new username:', err?.message);
                        }
                    }
                    
                    // Force reload profile from Firestore to verify
                    setTimeout(async () => {
                        console.log('üîÑ Reloading profile to verify save...');
                        try {
                            const testDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'profiles', userId));
                            if (testDoc.exists()) {
                                console.log('‚úÖ Verified - Public profile now contains:', testDoc.data());
                            } else {
                                console.warn('‚ö†Ô∏è Public profile doc still missing');
                            }
                        } catch (err) {
                            console.error('‚ùå Error verifying profile:', err);
                        }
                    }, 1000);
                } else {
                    setProfileStatus('Error saving profile.', true);
                }
            });
            } else {
                console.error('‚ùå Save Profile button NOT found! Element with id="save-profile-btn" does not exist.');
            }

            function setProfileStatus(message, isError = false) {
                if (!profileStatus) return;
                profileStatus.textContent = message;
                profileStatus.style.color = isError ? '#ff6b6b' : '#9ae6b4';
            }

            function normalizeBeatsInput(rawText) {
                const parsed = JSON.parse(rawText);
                const beats = Array.isArray(parsed) ? parsed : parsed?.beats;
                if (!Array.isArray(beats)) {
                    throw new Error('JSON must be an array or an object with a beats array.');
                }
                const cleaned = beats.map((beat, index) => {
                    if (!beat?.name || !beat?.buyUrl || !beat?.fileUrl) {
                        throw new Error(`Beat #${index + 1} is missing name, buyUrl, or fileUrl.`);
                    }
                    return {
                        name: String(beat.name),
                        price: Number(beat.price ?? 100),
                        buyUrl: String(beat.buyUrl),
                        fileUrl: String(beat.fileUrl)
                    };
                });
                return cleaned;
            }

            document.getElementById('beats-admin-load')?.addEventListener('click', async () => {
                await loadBeats();
                setBeatsAdminStatus('Loaded current beats.');
            });

            document.getElementById('beats-admin-save')?.addEventListener('click', async () => {
                try {
                    const text = document.getElementById('beats-admin-json')?.value || '';
                    const beats = normalizeBeatsInput(text);
                    const saved = await saveBeatsToFirestore(beats);
                    if (!saved) {
                        setBeatsAdminStatus('Unable to save beats. Check Firebase config.', true);
                        return;
                    }
                    BEAT_PACKAGES = beats;
                    buildBeatOptions();
                    setBeatsAdminStatus('Beats saved successfully.');
                } catch (error) {
                    setBeatsAdminStatus(error.message || 'Invalid JSON input.', true);
                }
            });

            document.querySelectorAll('.toggle-admin-btn').forEach(btn => {
                btn.addEventListener('click', toggleAdminMode);
            });

            // Pisces Ghost profile photo upload
            document.getElementById('generate-avatar-btn')?.addEventListener('click', () => {
                document.getElementById('pisces-avatar-upload')?.click();
            });

            document.getElementById('pisces-avatar-upload')?.addEventListener('change', async (e) => {
                const file = e.target.files?.[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (event) => {
                    const dataURL = event.target?.result;
                    try {
                        // Update user avatar display
                        const userAvatar = document.getElementById('user-avatar');
                        if (userAvatar) userAvatar.src = dataURL;
                        
                        // Save to Firestore user profile
                        if (userId && db) {
                            await setDoc(doc(db, 'artifacts', appId, 'users', userId, 'profile', 'data'), { profilePhoto: dataURL }, { merge: true });
                            showMessage('‚ú® Profile photo updated!');
                        }
                    } catch (error) {
                        console.error('Profile photo upload error:', error);
                        showMessage('Error saving profile photo');
                    }
                };
                reader.readAsDataURL(file);
            });

            // First Lady admin photo upload
            document.getElementById('change-first-lady-btn')?.addEventListener('click', () => {
                currentUploadTarget = 'first-lady';
                document.getElementById('admin-image-upload')?.click();
            });

            document.getElementById('admin-image-upload')?.addEventListener('change', async (e) => {
                const file = e.target.files?.[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (event) => {
                    const dataURL = event.target?.result;
                    try {
                        if (currentUploadTarget === 'first-lady') {
                            const goodDGirlAvatar = document.getElementById('Good-D-Girl-avatar');
                            if (goodDGirlAvatar) {
                                goodDGirlAvatar.src = dataURL;
                                // Save to Firestore for all users to see
                                if (db) {
                                    await setDoc(doc(db, 'artifacts', appId, 'public', 'data'), 
                                        { firstLadyPhoto: dataURL, updatedAt: serverTimestamp() }, 
                                        { merge: true }
                                    );
                                }
                                showMessage('‚ú® First Lady photo updated for everyone!');
                            }
                        }
                    } catch (error) {
                        console.error('Admin upload error:', error);
                        showMessage('Error saving photo');
                    }
                };
                reader.readAsDataURL(file);
            });

            // Zodiac Council photo uploads
            document.querySelectorAll('.change-zodiac-btn').forEach((btn) => {
                btn.addEventListener('click', (e) => {
                    const zodiacMember = e.target.closest('.zodiac-member');
                    const zodiacSign = zodiacMember?.getAttribute('data-sign');
                    if (!zodiacSign) return;
                    
                    currentUploadTarget = zodiacSign;
                    
                    // Create temporary file input for this zodiac
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    input.onchange = async (event) => {
                        const file = event.target.files?.[0];
                        if (!file) return;

                        const reader = new FileReader();
                        reader.onload = async (loadEvent) => {
                            const dataURL = loadEvent.target?.result;
                            try {
                                // Update zodiac avatar image
                                const zodiacAvatar = zodiacMember?.querySelector('.zodiac-avatar');
                                if (zodiacAvatar) {
                                    zodiacAvatar.src = dataURL;
                                    
                                    // Save to Firestore for all users to see
                                    if (db) {
                                        const currentCouncil = (await getDoc(doc(db, 'artifacts', appId, 'public', 'data'))).data()?.zodiacCouncil || {};
                                        await setDoc(doc(db, 'artifacts', appId, 'public', 'data'), 
                                            { zodiacCouncil: { ...currentCouncil, [zodiacSign]: dataURL }, updatedAt: serverTimestamp() }, 
                                            { merge: true }
                                        );
                                    }
                                    showMessage(`‚ú® ${zodiacSign.charAt(0).toUpperCase() + zodiacSign.slice(1)} photo updated for everyone!`);
                                }
                            } catch (error) {
                                console.error('Zodiac upload error:', error);
                                showMessage('Error updating zodiac photo');
                            }
                        };
                        reader.readAsDataURL(file);
                    };
                    input.click();
                });
            });

            // === BALANCE & GIFT BOX FUNCTIONS ===
            
            let userBalance = 0;
            
            async function loadUserBalance() {
                if (!userId || !db) return;
                try {
                    const userProfileDoc = doc(db, 'artifacts', appId, 'users', userId, 'profile', 'data');
                    const docSnap = await getDoc(userProfileDoc);
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        userBalance = data.balance || 0;
                        
                        // Load saved profile photo if exists
                        if (data.profilePhoto && userAvatar) {
                            userAvatar.src = data.profilePhoto;
                        }
                    } else {
                        userBalance = 0;
                        // Initialize balance if not exists
                        await setDoc(userProfileDoc, { balance: 0 }, { merge: true });
                    }
                    updateBalanceDisplay();
                } catch (error) {
                    console.error('Error loading balance:', error);
                }
            }
            
            function updateBalanceDisplay() {
                if (balanceHomeDisplay) balanceHomeDisplay.textContent = userBalance;
                if (balanceAccountDisplay) balanceAccountDisplay.textContent = userBalance;
            }
            
            function buildGiftboxModal() {
                giftsContainer.innerHTML = '';
                GIFTS.forEach(gift => {
                    const giftCard = document.createElement('div');
                    giftCard.className = 'gift-card';
                    giftCard.innerHTML = `
                        <div class="gift-emoji">${gift.emoji}</div>
                        <div class="gift-card-title">${gift.name}</div>
                        <div class="gift-card-price">Cost: $${gift.cost}</div>
                        <button class="gift-buy-btn" data-gift-id="${gift.id}" ${userBalance < gift.cost ? 'disabled' : ''}>
                            ${userBalance < gift.cost ? '‚ùå Not Enough' : '‚ú® Send Gift'}
                        </button>
                    `;
                    giftsContainer.appendChild(giftCard);
                });
            }
            
            function openGiftbox() {
                buildGiftboxModal();
                
                // Show/hide recipient display
                const recipientDisplay = document.getElementById('gift-recipient-display');
                const recipientNameSpan = document.getElementById('gift-recipient-name');
                
                if (selectedGiftUser) {
                    // Load and display full user profile with photo
                    getUserProfile(selectedGiftUser).then(profile => {
                        const displayName = profile.name || selectedGiftUserEmail || `User-${selectedGiftUser.slice(0, 6)}`;
                        const photoUrl = profile.photo;
                        const photoHtml = photoUrl ? `<img src="${photoUrl}" alt="${displayName}" class="user-profile-photo" />` : '<div style="width:2.5rem; height:2.5rem; border-radius:50%; background:#6b7280;"></div>';
                        
                        recipientNameSpan.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 0.75rem; background: rgba(99, 102, 241, 0.1); padding: 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(139, 92, 246, 0.3);">
                                ${photoHtml}
                                <div>
                                    <div style="font-weight: 600; color: #fbbf24; margin-bottom: 0.25rem;">${displayName}</div>
                                    <div style="font-size: 0.75rem; color: #9ca3af;">${displayName ? '‚úì Recipient selected' : 'Anonymous user'}</div>
                                </div>
                            </div>
                        `;
                        recipientDisplay.classList.remove('hidden');
                    });
                } else if (selectedGiftUserEmail) {
                    // Fallback for email-only recipients (old flow)
                    recipientNameSpan.textContent = selectedGiftUserEmail;
                    recipientDisplay.classList.remove('hidden');
                } else {
                    recipientDisplay.classList.add('hidden');
                }
                
                giftboxModal.classList.remove('hidden');
            }
            
            function closeGiftbox() {
                giftboxModal.classList.add('hidden');
            }
            
            async function sendGift(giftId) {
                const gift = GIFTS.find(g => g.id === giftId);
                if (!gift) return;
                
                if (userBalance < gift.cost) {
                    showMessage(`Not enough balance! You need $${gift.cost}, you have $${userBalance}.`);
                    return;
                }
                
                try {
                    // Deduct balance
                    userBalance -= gift.cost;
                    await setDoc(doc(db, 'artifacts', appId, 'users', userId, 'profile', 'data'), { balance: userBalance }, { merge: true });
                    updateBalanceDisplay();
                    
                    // Play gift animation
                    playGiftAnimation(gift.emoji);
                    
                    // Record gift sent
                    const giftsRef = collection(db, 'artifacts', appId, 'users', userId, 'gifts_sent');
                    await addDoc(giftsRef, {
                        giftId: gift.id,
                        giftName: gift.name,
                        sentAt: serverTimestamp(),
                        recipientId: selectedGiftUser || null,
                        recipientName: selectedGiftUserEmail || null
                    });

                    if (selectedGiftUser) {
                        const receivedRef = collection(db, 'artifacts', appId, 'users', selectedGiftUser, 'gifts_received');
                        await addDoc(receivedRef, {
                            giftId: gift.id,
                            giftName: gift.name,
                            fromUserId: userId,
                            fromUserName: auth?.currentUser?.email || auth?.currentUser?.displayName || `User-${userId.slice(0, 6)}`,
                            receivedAt: serverTimestamp()
                        });
                    }

                    const recipientLabel = selectedGiftUserEmail ? ` to ${selectedGiftUserEmail}` : '';
                    showMessage(`‚ú® ${gift.name} sent${recipientLabel}! $${userBalance} remaining.`);
                    selectedGiftUser = null;
                    selectedGiftUserEmail = null;
                    closeGiftbox();
                } catch (error) {
                    console.error('Error sending gift:', error);
                    showMessage('Error sending gift. Please try again.');
                }
            }
            
            function playGiftAnimation(emoji) {
                if (!giftEmojiContainer) return;
                giftAnimation?.classList.remove('hidden');
                giftAnimation?.classList.add('show');

                const burstCount = 10;
                for (let i = 0; i < burstCount; i += 1) {
                    const node = document.createElement('div');
                    node.className = 'gift-float';
                    node.textContent = emoji;
                    node.style.left = `${Math.random() * 80 + 10}%`;
                    node.style.bottom = `${Math.random() * 20 + 5}%`;
                    node.style.animationDelay = `${Math.random() * 0.6}s`;
                    node.style.fontSize = `${Math.random() * 1.5 + 2.5}rem`;
                    giftEmojiContainer.appendChild(node);

                    node.addEventListener('animationend', () => {
                        node.remove();
                    });
                }

                setTimeout(() => {
                    if (giftEmojiContainer.childElementCount === 0) {
                        giftAnimation?.classList.add('hidden');
                        giftAnimation?.classList.remove('show');
                    }
                }, 4000);
            }

            function playCameraGiftAnimation(emoji, message) {
                if (!cameraGiftOverlay) return;

                const burstCount = 12;
                for (let i = 0; i < burstCount; i += 1) {
                    const node = document.createElement('div');
                    node.className = 'gift-animation';
                    node.textContent = emoji;
                    node.style.left = `${Math.random() * 80 + 10}%`;
                    node.style.bottom = `${Math.random() * 15 + 5}%`;
                    node.style.animationDuration = `${Math.random() * 1 + 2.5}s`;
                    node.style.fontSize = `${Math.random() * 1.5 + 2.5}rem`;
                    cameraGiftOverlay.appendChild(node);

                    node.addEventListener('animationend', () => {
                        node.remove();
                    });
                }

                if (message) {
                    const note = document.createElement('div');
                    note.className = 'gift-notification';
                    note.textContent = message;
                    cameraGiftOverlay.appendChild(note);
                    note.addEventListener('animationend', () => {
                        note.remove();
                    });
                }
            }

            function listenForGiftReceipts() {
                if (!db || !appId || !userId) return;

                const receivedRef = collection(db, 'artifacts', appId, 'users', userId, 'gifts_received');
                const receivedQuery = query(receivedRef, orderBy('receivedAt', 'desc'), limit(50));

                onSnapshot(receivedQuery, async (snapshot) => {
                    if (!giftsListenerReady) {
                        snapshot.docs.forEach(docSnap => processedGiftIds.add(docSnap.id));
                        giftsListenerReady = true;
                        return;
                    }

                    const changes = snapshot.docChanges();
                    for (const change of changes) {
                        if (change.type !== 'added') continue;
                        const docSnap = change.doc;
                        if (processedGiftIds.has(docSnap.id)) continue;
                        processedGiftIds.add(docSnap.id);

                        const data = docSnap.data() || {};
                        const gift = GIFTS.find(g => g.id === data.giftId);
                        const amount = gift?.cost ?? 0;
                        const giftName = gift?.name || data.giftName || 'a gift';
                        const giftEmoji = gift?.emoji || 'üéÅ';
                        const senderName = data.fromUserName || 'Someone';

                        if (amount > 0) {
                            await setDoc(
                                doc(db, 'artifacts', appId, 'users', userId, 'profile', 'data'),
                                { balance: increment(amount) },
                                { merge: true }
                            );
                            userBalance += amount;
                            updateBalanceDisplay();
                        }

                        const amountLabel = amount > 0 ? ` (+$${amount})` : '';
                        playCameraGiftAnimation(giftEmoji, `${senderName} sent ${giftName}${amountLabel}`);
                    }
                });
            }
            
            // Giftbox modal event listeners
            if (giftboxIconHome) {
                giftboxIconHome.addEventListener('click', openGiftbox);
            }
            
            if (closeGiftboxModal) {
                closeGiftboxModal.addEventListener('click', closeGiftbox);
            }
            
            giftboxModal.addEventListener('click', (e) => {
                if (e.target === giftboxModal) {
                    closeGiftbox();
                }
            });
            
            giftsContainer.addEventListener('click', (e) => {
                if (e.target.classList.contains('gift-buy-btn')) {
                    const giftId = e.target.getAttribute('data-gift-id');
                    sendGift(giftId);
                }
            });
            
            // Balance purchase buttons
            function buildBalanceOptions() {
                if (!balanceOptions) return;
                balanceOptions.innerHTML = '';

                BALANCE_PACKAGES.forEach(pkg => {
                    const button = document.createElement('button');
                    button.className = 'gift-buy-btn';
                    button.textContent = `${pkg.icon} ${pkg.label} = ${pkg.credits} credits`;
                    button.addEventListener('click', () => {
                        if (!pkg.url || pkg.url.includes('example')) {
                            showMessage('Add your Stripe checkout URL for this package.');
                            return;
                        }
                        window.location.href = pkg.url;
                    });
                    balanceOptions.appendChild(button);
                });
            }

            function buildBeatOptions() {
                if (!beatOptions) return;
                beatOptions.innerHTML = '';

                BEAT_PACKAGES.forEach(beat => {
                    const card = document.createElement('div');
                    card.className = 'bg-gray-800 p-3 rounded-lg border border-yellow-700';
                    card.innerHTML = `
                        <p class="text-sm font-bold text-yellow-200">${beat.name}</p>
                        <p class="text-xs text-gray-400">$${beat.price} ‚Ä¢ Includes license</p>
                        <div class="flex flex-col gap-2 mt-2">
                            <audio controls class="w-full" style="height: 32px;">
                                <source src="${beat.fileUrl}" type="video/mp4">
                            </audio>
                            <button class="gift-buy-btn" data-buy-url="${beat.buyUrl}">Buy & Download</button>
                            <p class="text-xs text-gray-400 italic">Files & licenses sent after purchase</p>
                        </div>
                    `;
                    card.querySelector('button')?.addEventListener('click', (e) => {
                        const url = e.currentTarget.getAttribute('data-buy-url');
                        if (!url || url.includes('example')) {
                            showMessage('Add your Stripe checkout URL for this beat.');
                            return;
                        }
                        window.location.href = url;
                    });
                    beatOptions.appendChild(card);
                });
            }

            function buildKidsSongOptions() {
                if (!kidsSongOptions) return;
                kidsSongOptions.innerHTML = '';

                KIDS_SONG_PACKAGES.forEach(song => {
                    const card = document.createElement('div');
                    card.className = 'bg-gray-800 p-3 rounded-lg border border-yellow-700';

                    card.innerHTML = `
                        <p class="text-sm font-bold text-yellow-200">${song.name}</p>
                        <p class="text-xs text-gray-400">$${song.price} ‚Ä¢ Includes license</p>
                        <div class="flex flex-col gap-2 mt-2">
                            <audio controls class="w-full" style="height: 32px;">
                                <source src="${song.fileUrl}" type="video/mp4">
                            </audio>
                            <button class="gift-buy-btn" data-buy-url="${song.buyUrl}">Buy & Download</button>
                            <p class="text-xs text-gray-400 italic">Files & license sent after purchase</p>
                        </div>
                    `;
                    card.querySelector('button')?.addEventListener('click', (e) => {
                        const url = e.currentTarget.getAttribute('data-buy-url');
                        if (!url || url.includes('example')) {
                            showMessage('Add your Stripe checkout URL for this song.');
                            return;
                        }
                        window.location.href = url;
                    });
                    kidsSongOptions.appendChild(card);
                });
            }

            function buildBeatStore() {
                if (!beatStoreGrid) return;
                beatStoreGrid.innerHTML = '';

                BEAT_PACKAGES.forEach(beat => {
                    const card = document.createElement('div');
                    card.className = 'bg-gray-800 p-4 rounded-lg border border-yellow-700 flex flex-col gap-2';
                    card.innerHTML = `
                        <p class="text-sm font-bold text-yellow-200">${beat.name}</p>
                        <p class="text-xs text-gray-400">$${beat.price} ‚Ä¢ Includes license</p>
                        <button class="gift-buy-btn" data-buy-url="${beat.buyUrl}">Buy & Unlock</button>
                        <a class="text-xs text-emerald-400 underline" href="${beat.fileUrl}" download>Download Beat (after purchase)</a>
                        <div class="flex gap-2 text-xs">
                            <a class="text-yellow-300 underline" href="/assets/LICENSE-PERSONAL.txt" download>Personal License</a>
                            <a class="text-yellow-300 underline" href="/assets/LICENSE-TEAM.txt" download>Team License</a>
                        </div>
                    `;
                    card.querySelector('button')?.addEventListener('click', (e) => {
                        const url = e.currentTarget.getAttribute('data-buy-url');
                        if (!url || url.includes('example')) {
                            showMessage('Add your Stripe checkout URL for this beat.');
                            return;
                        }
                        window.location.href = url;
                    });
                    beatStoreGrid.appendChild(card);
                });
            }

            function openBalanceModal() {
                buildBalanceOptions();
                buildBeatOptions();
                buildKidsSongOptions();
                balanceModal?.classList.remove('hidden');
            }

            function closeBalanceModalHandler() {
                balanceModal?.classList.add('hidden');
            }

            buyBalanceBtnHome?.addEventListener('click', openBalanceModal);
            buyBalanceBtnAccount?.addEventListener('click', openBalanceModal);
            buyBalanceBtnCamera?.addEventListener('click', openBalanceModal);
            closeBalanceModal?.addEventListener('click', closeBalanceModalHandler);
            balanceModal?.addEventListener('click', (e) => {
                if (e.target === balanceModal) {
                    closeBalanceModalHandler();
                }
            });

            giftPurchaseBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    openBalanceModal();
                });
            });

            document.addEventListener('click', (e) => {
                const target = e.target.closest('.gift-purchase-btn');
                if (!target) return;
                e.preventDefault();
                openBalanceModal();
            });

            buildBeatStore();

            // === CAMERA CHAT FUNCTIONS ===
            
            const cameraChat = document.getElementById('camera-chat');
            const cameraChatMessages = document.getElementById('camera-chat-messages');
            const cameraChatInput = document.getElementById('camera-chat-input');
            const cameraChatSend = document.getElementById('camera-chat-send');
            const toggleChatBtn = document.getElementById('toggle-chat-btn');
            
            let cameraChatMinimized = false;
            
            // Toggle chat minimized state
            toggleChatBtn?.addEventListener('click', () => {
                cameraChatMinimized = !cameraChatMinimized;
                if (cameraChatMinimized) {
                    cameraChat.classList.add('minimized');
                    toggleChatBtn.textContent = '‚ûï';
                } else {
                    cameraChat.classList.remove('minimized');
                    toggleChatBtn.textContent = '‚ûñ';
                }
            });
            
            // Send camera chat message
            async function sendChatMessage(message, inputToClear) {
                const trimmed = message?.trim();
                if (!trimmed || !userId || !db) {
                    if (!db) showMessage('Chat not ready yet. Please wait a moment.');
                    return;
                }

                const user = auth?.currentUser;
                const displayName = userProfile?.username || user?.email || user?.displayName || `User-${userId.slice(0, 6)}`;

                try {
                    const chatRef = collection(db, 'artifacts', appId, 'public', 'data', 'camera_chat');
                    await addDoc(chatRef, {
                        message: trimmed,
                        sender: displayName,
                        senderId: userId,
                        timestamp: serverTimestamp()
                    });
                    if (inputToClear) inputToClear.value = '';
                } catch (error) {
                    console.error('Error sending chat message:', error);
                }
            }

            async function sendSystemChatMessage({ senderId, senderName, message }) {
                if (!db || !appId || !message) return;
                try {
                    const chatRef = collection(db, 'artifacts', appId, 'public', 'data', 'camera_chat');
                    await addDoc(chatRef, {
                        message: message,
                        sender: senderName || 'System',
                        senderId: senderId || null,
                        timestamp: serverTimestamp()
                    });
                } catch (error) {
                    console.error('Error sending system chat message:', error);
                }
            }
            
            cameraChatSend?.addEventListener('click', () => sendChatMessage(cameraChatInput?.value, cameraChatInput));
            cameraChatInput?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendChatMessage(cameraChatInput?.value, cameraChatInput);
                }
            });

            // Add same listeners to floating chat
            const floatingChatSend = document.getElementById('floating-chat-send');
            const floatingChatInput = document.getElementById('floating-chat-input');
            
            floatingChatSend?.addEventListener('click', () => sendChatMessage(floatingChatInput?.value, floatingChatInput));
            
            floatingChatInput?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendChatMessage(floatingChatInput?.value, floatingChatInput);
                }
            });

            // Load team photos (First Lady and Zodiac Council) from Firestore
            async function loadTeamPhotos() {
                if (!db) return;
                
                try {
                    console.log('Loading team photos...');
                    
                    onSnapshot(doc(db, 'artifacts', appId, 'public', 'data'), (docSnap) => {
                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            if (data.firstLadyPhoto) {
                                const goodDGirlAvatar = document.getElementById('Good-D-Girl-avatar');
                                if (goodDGirlAvatar) {
                                    goodDGirlAvatar.src = data.firstLadyPhoto;
                                    console.log('First Lady photo loaded');
                                }
                            }
                            // Load zodiac council photos from same doc
                            if (data.zodiacCouncil) {
                                const zodiacData = data.zodiacCouncil;
                                document.querySelectorAll('.zodiac-member').forEach(member => {
                                    const sign = member.getAttribute('data-sign');
                                    if (sign && zodiacData[sign]) {
                                        const img = member.querySelector('.zodiac-avatar');
                                        if (img) {
                                            img.src = zodiacData[sign];
                                        }
                                    }
                                });
                                console.log('Zodiac council photos loaded');
                            }
                        }
                    });
                } catch (error) {
                    console.log('Error loading team photos:', error.message);
                }
            }
            
            // Cache for user profile lookups to avoid repeated Firestore queries
            const userProfileCache = {};
            
            // Function to get user's full profile info (name + photo)
            async function getUserProfile(senderId) {
                if (!senderId) return { name: 'Anonymous', photo: '' };
                
                // Check cache first
                if (userProfileCache[senderId]) {
                    console.log(`‚úÖ Cache hit for ${senderId}:`, userProfileCache[senderId]);
                    return userProfileCache[senderId];
                }
                
                console.log(`üîç Looking up full profile for ${senderId}...`);
                try {
                    // Try to load from public profiles
                    const profileDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'profiles', senderId));
                    if (profileDoc.exists()) {
                        const data = profileDoc.data();
                        console.log(`üìÑ Public profile doc found:`, data);
                        const profile = {
                            name: data.username || data.displayName || `User-${senderId.slice(0, 6)}`,
                            photo: data.profilePhoto || data.photoUrl || ''
                        };
                        userProfileCache[senderId] = profile;
                        console.log(`‚úÖ Found full profile for ${senderId}:`, profile);
                        return profile;
                    } else {
                        console.log(`‚ùå No public profile document found for ${senderId}`);
                        // Try private profile as fallback
                        try {
                            const privateDoc = await getDoc(doc(db, 'artifacts', appId, 'users', senderId, 'profile', 'data'));
                            if (privateDoc.exists()) {
                                const data = privateDoc.data();
                                console.log(`üìÑ Private profile doc found:`, data);
                                const profile = {
                                    name: data.username || data.displayName || `User-${senderId.slice(0, 6)}`,
                                    photo: data.profilePhoto || data.photoUrl || ''
                                };
                                userProfileCache[senderId] = profile;
                                console.log(`‚úÖ Found private profile for ${senderId}:`, profile);
                                return profile;
                            }
                        } catch (err) {
                            console.warn(`Failed to load private profile:`, err?.message);
                        }
                    }
                } catch (error) {
                    console.warn(`Failed to load profile for ${senderId}:`, error?.message || error);
                }
                
                // Fallback: show shortened user ID
                const fallback = {
                    name: `User-${senderId.slice(0, 6)}`,
                    photo: ''
                };
                userProfileCache[senderId] = fallback;
                console.log(`‚ö†Ô∏è Using fallback profile for ${senderId}:`, fallback);
                return fallback;
            }
            
            // Function to get user's display name from profile (for backwards compatibility)
            async function getUserDisplayName(senderId) {
                const profile = await getUserProfile(senderId);
                return profile.name;
            }
            
            // Listen for camera chat messages
            function createChatMessageElement(msg) {
                console.log('üé® Creating chat message element:', msg);
                const messageDiv = document.createElement('div');
                messageDiv.className = 'camera-chat-message';

                const senderDiv = document.createElement('div');
                senderDiv.className = 'camera-chat-sender';
                senderDiv.setAttribute('data-sender-id', msg.senderId);
                
                // Use sender name from message if available, otherwise will load from profile
                let displayName = msg.sender || 'Loading...';
                let photoUrl = '';
                console.log(`üë§ Initial display name for ${msg.senderId}:`, displayName);
                
                // Define gift click handler
                const handleGiftClick = () => {
                    if (msg.senderId === userId) {
                        showMessage('That\'s you! You can\'t send a gift to yourself.');
                        return;
                    }
                    selectedGiftUser = msg.senderId;
                    selectedGiftUserEmail = displayName;
                    // Show a nice notification with profile info
                    const message = `üíù Selected ${displayName} as gift recipient! Click the üéÅ giftbox icon to send a gift.`;
                    showMessage(message);
                    // Auto-open giftbox to make it easy
                    setTimeout(() => openGiftbox(), 300);
                };
                
                // Function to render sender with photo and name
                const renderSender = (name, photo) => {
                    const photoHtml = photo ? `<img src="${photo}" alt="${name}" style="width:24px; height:24px; border-radius:50%; margin-right:0.5rem; vertical-align:middle;">` : '';
                    senderDiv.innerHTML = `${photoHtml}<span style="vertical-align:middle;">${name}</span> <button class="gift-icon-btn" style="cursor:pointer; background:none; border:none; padding:0.25rem 0.5rem; margin-left:0.5rem; font-size:1.1rem; hover:scale-110;">üéÅ</button>`;
                    senderDiv.setAttribute('data-sender-name', name);
                };
                
                // Set initial HTML
                renderSender(displayName, photoUrl);
                
                // Attach event listeners
                const attachGiftHandlers = () => {
                    senderDiv.addEventListener('click', handleGiftClick);
                    senderDiv.querySelectorAll('.gift-icon-btn').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            handleGiftClick();
                        });
                    });
                };
                attachGiftHandlers();
                
                // If sender name is not in the message, load it from profile
                if (!msg.sender || msg.sender === 'Anonymous') {
                    console.log(`üìö Need to load full profile for ${msg.senderId}`);
                    getUserProfile(msg.senderId).then(profile => {
                        console.log(`‚ú® Updated profile for ${msg.senderId}:`, profile);
                        displayName = profile.name;
                        photoUrl = profile.photo;
                        renderSender(displayName, photoUrl);
                        attachGiftHandlers();
                    });
                }

                const textDiv = document.createElement('div');
                textDiv.className = 'camera-chat-text';
                textDiv.textContent = msg.message || '';

                messageDiv.appendChild(senderDiv);
                messageDiv.appendChild(textDiv);
                return messageDiv;
            }

            function setupCameraChatListener() {
                if (!db) {
                    console.warn('‚ö†Ô∏è Chat listener: db not initialized');
                    return;
                }
                
                console.log('üé§ Setting up camera chat listener...');
                const chatRef = collection(db, 'artifacts', appId, 'public', 'data', 'camera_chat');
                const chatQuery = query(chatRef, orderBy('timestamp', 'desc'), limit(50));
                
                onSnapshot(chatQuery, (snapshot) => {
                    console.log(`üì® Received ${snapshot.size} chat messages`);
                    const messages = [];
                    snapshot.forEach(doc => {
                        messages.push({ id: doc.id, ...doc.data() });
                    });
                    
                    // Reverse to show oldest first
                    messages.reverse();
                    console.log('üí¨ Displaying messages:', messages.length);
                    
                    cameraChatMessages.innerHTML = '';
                    const floatingChatMessages = document.getElementById('floating-chat-messages');
                    if (floatingChatMessages) floatingChatMessages.innerHTML = '';

                    messages.forEach(msg => {
                        if (cameraChatMessages) {
                            cameraChatMessages.appendChild(createChatMessageElement(msg));
                        }
                        if (floatingChatMessages) {
                            floatingChatMessages.appendChild(createChatMessageElement(msg));
                        }
                    });
                    
                    // Auto-scroll to bottom
                    cameraChatMessages.scrollTop = cameraChatMessages.scrollHeight;
                    if (floatingChatMessages) {
                        floatingChatMessages.scrollTop = floatingChatMessages.scrollHeight;
                    }
                }, (error) => {
                    console.error('‚ùå Error listening to camera chat:', error);
                });
            }

            // --- Multi-Device Presence System (User-Based, Auto-Cleanup, Scalable) ---
            let presenceHeartbeatInterval = null;
            let presenceUnsubscribe = null;
            let presenceUnloadHandler = null;
            let currentPresenceRef = null;
            let currentPresenceDeviceId = null;
            let currentPresenceUserId = null;
            const PRESENCE_HEARTBEAT_INTERVAL = 15000; // 15 seconds (less throttling risk in background tabs)
            const PRESENCE_ONLINE_THRESHOLD = 180000; // 3 minutes before marking device as offline
            
            // Generate a unique device ID on first load
            function generateDeviceId() {
                let deviceId = '';
                try {
                    deviceId = sessionStorage.getItem('studioDeviceId') || '';
                } catch (e) {
                    deviceId = '';
                }
                if (!deviceId) {
                    deviceId = `device-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    try {
                        sessionStorage.setItem('studioDeviceId', deviceId);
                    } catch (e) {}
                }
                return deviceId;
            }
            
            // Generate or get a studio session ID (persists across devices in same browser)
            function getStudioSessionId() {
                let sessionId = sessionStorage.getItem('studioSessionId');
                if (!sessionId) {
                    sessionId = `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    sessionStorage.setItem('studioSessionId', sessionId);
                }
                return sessionId;
            }
            
            async function setupOnlinePresence() {
                if (!userId || !db) {
                    dlog('setupOnlinePresence: Missing userId or db', { userId: !!userId, db: !!db });
                    return;
                }
                
                const user = auth?.currentUser;
                const userEmail = user?.email || `Anonymous-${userId.slice(0, 8)}`;
                const userName = userProfile?.username || userEmail;
                const deviceId = generateDeviceId();

                if (presenceHeartbeatInterval) {
                    clearInterval(presenceHeartbeatInterval);
                    presenceHeartbeatInterval = null;
                }
                if (presenceUnsubscribe) {
                    presenceUnsubscribe();
                    presenceUnsubscribe = null;
                }
                if (presenceUnloadHandler) {
                    window.removeEventListener('beforeunload', presenceUnloadHandler);
                    presenceUnloadHandler = null;
                }
                if (currentPresenceRef && currentPresenceDeviceId && (currentPresenceUserId !== userId || currentPresenceDeviceId !== deviceId)) {
                    try {
                        await updateDoc(currentPresenceRef, {
                            [`devices.${currentPresenceDeviceId}`]: deleteField()
                        });
                        dlog(`üîå Cleaned previous presence device ${currentPresenceDeviceId}`);
                    } catch (err) {
                        console.warn('Could not clean previous presence device:', err?.message || err);
                    }
                }
                
                // Use user ID as the presence document key (one doc per user, multiple devices inside)
                const presenceRef = doc(db, 'artifacts', appId, 'presence', userId);
                currentPresenceRef = presenceRef;
                currentPresenceDeviceId = deviceId;
                currentPresenceUserId = userId;
                
                    // Initialize presence document with this device
                    // Don't await - let it complete in background to avoid blocking
                    const presenceData = {
                        email: userEmail,
                        username: userName,
                        userId: userId,
                        username: userName,
                        userId: userId,
                        devices: {
                            [deviceId]: {
                                lastSeen: serverTimestamp(),
                                lastSeenLocal: Date.now(),
                                deviceId: deviceId
                            }
                        }
                    };
                    dlog('Presence data to write:', JSON.stringify(presenceData, null, 2));
                    
                    // Fire and forget - don't block on this
                    setDoc(presenceRef, presenceData, { merge: true })
                        .then(() => {
                            dlog('‚úÖ Presence initialized in background');
                        })
                        .catch(err => {
                            console.error('‚ùå Background presence init error:', err);
                            console.error('‚ùå Error code:', err.code);
                            console.error('‚ùå Error message:', err.message);
                            console.error('‚ùå Full error:', err);
                        });
                
                // Heartbeat: Update device timestamp every 5 seconds
                presenceHeartbeatInterval = setInterval(async () => {
                    try {
                        await updateDoc(presenceRef, {
                            [`devices.${deviceId}.lastSeen`]: serverTimestamp(),
                            [`devices.${deviceId}.lastSeenLocal`]: Date.now()
                        });
                        dlog(`‚úÖ HEARTBEAT: Updated ${deviceId}`);
                    } catch (err) {
                        console.error('‚ùå Error updating presence heartbeat:', err);
                        
                        // If we get a not-found error, try to recreate the presence doc
                        if (err.code === 'not-found') {
                            dlog('‚ö†Ô∏è Presence document not found, recreating...');
                            try {
                                await setDoc(presenceRef, {
                                    email: userEmail,
                                    username: userName,
                                    userId: userId,
                                    devices: {
                                        [deviceId]: {
                                            lastSeen: serverTimestamp(),
                                            lastSeenLocal: Date.now(),
                                            deviceId: deviceId
                                        }
                                    }
                                }, { merge: true });
                                dlog('‚úÖ Presence document recreated');
                            } catch (recreateErr) {
                                console.error('‚ùå Failed to recreate presence:', recreateErr);
                            }
                        }
                    }
                }, PRESENCE_HEARTBEAT_INTERVAL);
                
                // Listen for all online users
                const presenceQuery = query(collection(db, 'artifacts', appId, 'presence'));
                
                presenceUnsubscribe = onSnapshot(
                    presenceQuery,
                    (snapshot) => {
                    dlog(`üìä PRESENCE UPDATE: Found ${snapshot.size} total user documents`);
                    const onlineUsers = [];
                    const now = Date.now();
                    
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const isAnonymousPresence = typeof data.email === 'string' && data.email.startsWith('Anonymous-');
                        const devices = data.devices || {};
                        
                        const resolveEffectiveLastSeen = (device) => {
                            let serverSeen = device.lastSeen;
                            if (serverSeen && typeof serverSeen === 'object' && serverSeen.toMillis) {
                                serverSeen = serverSeen.toMillis();
                            } else if (typeof serverSeen !== 'number') {
                                serverSeen = 0;
                            }
                            const localSeen = typeof device.lastSeenLocal === 'number' ? device.lastSeenLocal : 0;
                            return Math.max(serverSeen, localSeen);
                        };

                        // Check if ANY device is active (heartbeat within threshold)
                        const isUserOnline = Object.values(devices).some(device => {
                            const effectiveLastSeen = resolveEffectiveLastSeen(device);
                            const isActive = now - effectiveLastSeen < PRESENCE_ONLINE_THRESHOLD;
                            return isActive;
                        });
                        
                        // Count active devices for this user and pick the freshest active device
                        const activeDeviceEntries = Object.entries(devices)
                            .filter(([, device]) => {
                                const effectiveLastSeen = resolveEffectiveLastSeen(device);
                                return now - effectiveLastSeen < PRESENCE_ONLINE_THRESHOLD;
                            })
                            .sort(([, a], [, b]) => resolveEffectiveLastSeen(b) - resolveEffectiveLastSeen(a));
                        const activeDeviceCount = activeDeviceEntries.length;
                        const primaryDeviceId = activeDeviceEntries.length ? activeDeviceEntries[0][0] : null;

                        if (isUserOnline) {
                            onlineUsers.push({
                                id: doc.id,
                                isSelf: doc.id === userId,
                                email: data.email,
                                username: data.username,
                                isAnonymousPresence,
                                devices: activeDeviceCount,
                                deviceList: Object.keys(devices),
                                activeDeviceIds: activeDeviceEntries.map(([id]) => id),
                                primaryDeviceId
                            });
                        }
                    });
                    dlog(`üìä FINAL: ${onlineUsers.length} users online`);
                    
                    // Update online count in nav tab
                    const navOnlineCount = document.getElementById('nav-online-count');
                    if (navOnlineCount) {
                        navOnlineCount.textContent = onlineUsers.length;
                    }
                    
                    // Display online users in the Online page (query fresh in case it wasn't available on first load)
                    const freshOnlineUsersList = document.getElementById('online-users-list');
                    if (freshOnlineUsersList) {
                        if (onlineUsers.length === 0) {
                            freshOnlineUsersList.innerHTML = '<p class="text-gray-400 text-sm">No users online</p>';
                        } else {
                            freshOnlineUsersList.innerHTML = '';
                            // Render each user with their profile using Promise.all
                            Promise.all(onlineUsers.map(async (user) => {
                                const userItem = document.createElement('div');
                                userItem.className = `online-user-item ${user.isSelf ? 'self' : ''}`;
                                
                                // Get full profile with photo (but use username from presence as fallback)
                                const profile = await getUserProfile(user.id);
                                const displayName = profile.name || user.username || user.email || `User-${user.id.slice(0, 6)}`;
                                const photoUrl = profile.photo || '';
                                const targetIsCallable = !user.isAnonymousPresence;
                                
                                const photoHtml = photoUrl ? `<img src="${photoUrl}" alt="${displayName}" class="user-profile-photo-small" />` : '<div style="width:1.5rem; height:1.5rem; border-radius:50%; background:#6b7280; flex-shrink:0;"></div>';
                                const label = user.isSelf
                                    ? 'üü¢ You'
                                    : (user.isAnonymousPresence ? 'üü° Online (anonymous)' : 'üü¢ Online');
                                const canCallNow = canUseCalling();
                                
                                let buttonHtml = '';
                                if (!user.isSelf && targetIsCallable) {
                                    const callBtnClass = canCallNow
                                        ? 'text-xs bg-green-600 hover:bg-green-700 px-2 py-1 rounded call-user-btn'
                                        : 'text-xs bg-gray-600 text-gray-300 px-2 py-1 rounded opacity-80 call-user-btn';
                                    const callBtnTitle = canCallNow ? 'Call user' : 'Sign in to call';
                                    buttonHtml = `<button class="${callBtnClass}" title="${callBtnTitle}"><span style="margin-right: 0.25rem;">üìû</span>Call</button>`;
                                }
                                
                                userItem.innerHTML = `
                                    <div style="display: flex; align-items: center; gap: 0.5rem; flex: 1;">
                                        ${photoHtml}
                                        <div style="min-width: 0;">
                                            <div class="user-profile-name">${displayName}</div>
                                            <div class="user-profile-status">${label}</div>
                                        </div>
                                    </div>
                                    ${buttonHtml}
                                `;
                                
                                // Add event listeners
                                if (!user.isSelf && targetIsCallable) {
                                    const callBtn = userItem.querySelector('.call-user-btn');
                                    const handleCallAttempt = () => {
                                        if (!canUseCalling()) {
                                            showMessage('Please sign in with Google or email to enable calling.');
                                            try { switchPage('account'); } catch (e) {}
                                            return;
                                        }
                                        initiateCall(user.id, user.email || '', user.primaryDeviceId, displayName);
                                    };

                                    if (callBtn) {
                                        callBtn.addEventListener('click', (e) => {
                                            e.stopPropagation();
                                            handleCallAttempt();
                                        });
                                    }
                                    userItem.style.cursor = canCallNow ? 'pointer' : 'default';
                                    userItem.title = canCallNow ? 'Click to call' : 'Sign in with Google or email to enable calling';
                                    userItem.addEventListener('click', () => {
                                        handleCallAttempt();
                                    });
                                } else if (!user.isSelf && user.isAnonymousPresence) {
                                    userItem.style.cursor = 'default';
                                    userItem.title = 'Anonymous session cannot receive direct calls. Sign in on that tab.';
                                }
                                
                                return userItem;
                            })).then(userItems => {
                                dlog(`‚úÖ Rendered ${userItems.length} user items`);
                                userItems.forEach(item => {
                                    if (freshOnlineUsersList) {
                                        freshOnlineUsersList.appendChild(item);
                                    }
                                });
                            }).catch(err => {
                                console.error('Error rendering online users:', err);
                            });
                        }
                    }
                }, 
                (error) => {
                    console.error('‚ùå Presence listener error:', error);
                    console.error('Error code:', error.code);
                    console.error('Error message:', error.message);
                }
            );
                
            // Remove this device from presence when leaving
                presenceUnloadHandler = async () => {
                    if (presenceHeartbeatInterval) clearInterval(presenceHeartbeatInterval);
                    
                    try {
                        if (currentPresenceRef && currentPresenceDeviceId) {
                            await updateDoc(currentPresenceRef, {
                                [`devices.${currentPresenceDeviceId}`]: deleteField()
                            });
                            dlog(`üîå Device ${currentPresenceDeviceId} marked offline`);
                        }
                    } catch (err) {
                        console.error('Error marking device offline:', err);
                    }
                };
                window.addEventListener('beforeunload', presenceUnloadHandler);
            }
            
            // --- Beat Audio Mixing (for calls) ---
            let audioContext;
            let beatAudioSource;
            let beatMediaElement;
            let beatGainNode;

            function getBeatMediaElement() {
                if (!customPlayer) return null;
                try {
                    const playerEl = typeof customPlayer.el === 'function' ? customPlayer.el() : null;
                    const videoEl = playerEl ? playerEl.querySelector('video') : null;
                    return videoEl || customPlayer.tech_?.el() || null;
                } catch (e) {
                    console.warn('Unable to resolve beat media element:', e);
                    return null;
                }
            }

            function ensureAudioContext() {
                if (!audioContext) {
                    const AudioCtx = window.AudioContext || window.webkitAudioContext;
                    if (!AudioCtx) return null;
                    audioContext = new AudioCtx();
                }
                if (audioContext.state === 'suspended') {
                    audioContext.resume().catch(() => {});
                }
                return audioContext;
            }

            async function attachBeatToCallStream(stream) {
                try {
                    if (!stream) return stream;

                    const beatEl = getBeatMediaElement();
                    if (!beatEl) return stream;

                    const ctx = ensureAudioContext();
                    if (!ctx) return stream;

                    const destination = ctx.createMediaStreamDestination();

                    // Mic source
                    const micSource = ctx.createMediaStreamSource(stream);
                    micSource.connect(destination);

                    // Beat source (reuse if already created)
                    if (!beatAudioSource || beatMediaElement !== beatEl) {
                        try {
                            if (beatAudioSource) beatAudioSource.disconnect();
                        } catch (e) {}
                        beatAudioSource = ctx.createMediaElementSource(beatEl);
                        beatMediaElement = beatEl;
                    }

                    if (beatGainNode) {
                        try {
                            beatGainNode.disconnect();
                        } catch (e) {}
                    }

                    beatGainNode = ctx.createGain();
                    beatGainNode.gain.value = 0.7; // Beat level in the mix

                    beatAudioSource.connect(beatGainNode).connect(destination);

                    const mixedTrack = destination.stream.getAudioTracks()[0];
                    if (mixedTrack) {
                        stream.getAudioTracks().forEach(track => stream.removeTrack(track));
                        stream.addTrack(mixedTrack);
                    }
                } catch (error) {
                    console.warn('Beat audio mix failed, using mic only:', error);
                }
                return stream;
            }

            // --- Simple Video Calling ---
            const servers = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun.services.mozilla.com' }
                ],
                iceCandidatePoolSize: 10
            };

            // --- Broadcast (host -> viewers) ---
            let broadcastId = null;
            let broadcastStream = null;
            let broadcastViewerUnsubscribe = null;
            let liveBroadcastUnsubscribe = null;
            let broadcastPeerConnections = new Map();
            let viewerPeerConnection = null;
            let currentViewingBroadcastId = null;
            let micEnabled = true;
            let monitorEnabled = false;
            let broadcastStartToken = 0;
            autoGoLiveEnabled = safeStorageGet('autoGoLiveHost', 'false') === 'true';
            selectedMicDeviceId = safeStorageGet('preferredMicDeviceId', '') || '';

            function setBroadcastStatus(text, isLive = false) {
                if (!broadcastStatus) return;
                broadcastStatus.textContent = text || '';
                broadcastStatus.style.color = isLive ? '#34d399' : '#f59e0b';
            }

            function updateHostModeUI() {
                if (hostModeBtn) {
                    hostModeBtn.textContent = autoGoLiveEnabled ? 'üëë Host Mode On' : 'üëë Host Mode Off';
                }
            }

            async function populateMicDevices() {
                if (!navigator.mediaDevices?.enumerateDevices || !micSelect) return;
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const mics = devices.filter(d => d.kind === 'audioinput');
                    micSelect.innerHTML = '';

                    if (!mics.length) {
                        const opt = document.createElement('option');
                        opt.value = '';
                        opt.textContent = 'No microphones found';
                        micSelect.appendChild(opt);
                        return;
                    }

                    mics.forEach((device) => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.textContent = device.label || `Microphone ${micSelect.length + 1}`;
                        micSelect.appendChild(option);
                    });

                    if (selectedMicDeviceId) {
                        micSelect.value = selectedMicDeviceId;
                    }
                } catch (error) {
                    console.warn('Unable to list microphones:', error);
                }
            }

            function getAudioConstraints() {
                if (selectedMicDeviceId) {
                    return { deviceId: { exact: selectedMicDeviceId } };
                }
                return true;
            }

            function setMicEnabled(enabled) {
                micEnabled = enabled;
                const updateTracks = (stream) => {
                    if (!stream) return;
                    stream.getAudioTracks().forEach(track => {
                        track.enabled = enabled;
                    });
                };
                updateTracks(broadcastStream);
                updateTracks(localStream);
                updateTracks(callStream);

                if (micToggleBtn) {
                    micToggleBtn.textContent = enabled ? 'üé§ Mic On' : 'üîá Mic Off';
                }
            }

            function updateMonitorStream() {
                if (!micMonitor) return;
                if (!monitorEnabled) {
                    micMonitor.pause?.();
                    micMonitor.srcObject = null;
                    return;
                }

                const stream = broadcastStream || callStream || localStream;
                if (stream) {
                    micMonitor.srcObject = stream;
                    micMonitor.muted = false;
                    micMonitor.play().catch(() => {});
                }
            }

            function setMonitorEnabled(enabled) {
                monitorEnabled = enabled;
                if (monitorToggleBtn) {
                    monitorToggleBtn.textContent = enabled ? 'üîä Monitor On' : 'üîä Monitor Off';
                }
                updateMonitorStream();
            }

            function showBroadcastVideo(stream) {
                if (broadcastVideo) {
                    broadcastVideo.srcObject = stream || null;
                    broadcastVideo.style.display = stream ? 'block' : 'none';
                    if (stream) {
                        broadcastVideo.play().catch(() => {});
                    }
                }
            }

            function showLocalCamera(show = true) {
                if (localVideo) {
                    localVideo.style.display = show ? 'block' : 'none';
                }
            }

            async function startBroadcast() {
                if (!db || !userId || broadcastId) return;
                try {
                    const startToken = Date.now();
                    broadcastStartToken = startToken;
                    setBroadcastStatus('Requesting camera/mic...', false);
                    if (goLiveBtn) goLiveBtn.disabled = true;

                    const permissionHintTimer = setTimeout(() => {
                        if (broadcastStartToken === startToken && !broadcastId) {
                            setBroadcastStatus('Waiting for camera/mic permission...', false);
                        }
                    }, 3000);

                    broadcastStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: getAudioConstraints() });
                    clearTimeout(permissionHintTimer);
                    setBroadcastStatus('Publishing...', false);
                    broadcastStream = await attachBeatToCallStream(broadcastStream);
                    setMicEnabled(micEnabled);
                    updateMonitorStream();
                    populateMicDevices();

                    if (localVideo) {
                        localVideo.srcObject = broadcastStream;
                        localVideo.muted = true;
                        localVideo.play().catch(() => {});
                    }

                    const finalizeBroadcastStart = (broadcastDoc) => {
                        if (!broadcastDoc || broadcastId || broadcastStartToken !== startToken) return;
                        broadcastId = broadcastDoc.id;
                        setBroadcastStatus('LIVE', true);
                        if (endLiveBtn) endLiveBtn.style.display = 'inline-flex';
                        if (goLiveBtn) goLiveBtn.style.display = 'none';
                    };

                    const addDocPromise = addDoc(collection(db, 'artifacts', appId, 'broadcasts'), {
                        hostId: userId,
                        status: 'live',
                        startedAt: serverTimestamp()
                    });

                    addDocPromise.then((broadcastDoc) => {
                        finalizeBroadcastStart(broadcastDoc);
                    }).catch(() => {});

                    const timeoutPromise = new Promise((_, reject) =>
                        setTimeout(() => reject(new Error('broadcast-start-timeout')), 12000)
                    );

                    const broadcastDoc = await Promise.race([addDocPromise, timeoutPromise]);
                    finalizeBroadcastStart(broadcastDoc);

                    const viewersRef = collection(db, 'artifacts', appId, 'broadcasts', broadcastId, 'viewers');
                    if (broadcastViewerUnsubscribe) broadcastViewerUnsubscribe();
                    broadcastViewerUnsubscribe = onSnapshot(viewersRef, (snapshot) => {
                        snapshot.docChanges().forEach(async (change) => {
                            if (change.type === 'added') {
                                await handleViewerJoin(change.doc.id, change.doc.ref);
                            }
                            if (change.type === 'removed') {
                                const pc = broadcastPeerConnections.get(change.doc.id);
                                if (pc) {
                                    pc.close();
                                    broadcastPeerConnections.delete(change.doc.id);
                                }
                            }
                        });
                    });
                } catch (error) {
                    console.error('Broadcast start failed:', error);
                    if (error?.message === 'broadcast-start-timeout') {
                        showMessage('‚ö†Ô∏è Network is slow. Try Go Live again.');
                        setBroadcastStatus('Network slow. Try again.', false);
                    } else {
                        showMessage('‚ùå Could not start broadcast. Click Go Live to allow microphone/camera permissions.');
                        setBroadcastStatus('', false);
                    }
                    if (goLiveBtn) goLiveBtn.disabled = false;
                }
            }

            async function handleViewerJoin(viewerId, viewerRef) {
                if (!broadcastStream || broadcastPeerConnections.has(viewerId)) return;

                const pc = new RTCPeerConnection(servers);
                broadcastPeerConnections.set(viewerId, pc);

                broadcastStream.getTracks().forEach(track => {
                    pc.addTrack(track, broadcastStream);
                });

                pc.onicecandidate = async (event) => {
                    if (event.candidate) {
                        await addDoc(collection(viewerRef, 'offerCandidates'), event.candidate.toJSON());
                    }
                };

                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                await setDoc(viewerRef, {
                    viewerId,
                    hostId: userId,
                    offer: { type: offer.type, sdp: offer.sdp },
                    status: 'offered'
                }, { merge: true });

                onSnapshot(viewerRef, async (snapshot) => {
                    const data = snapshot.data();
                    if (data?.answer && !pc.currentRemoteDescription) {
                        await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                    }
                });

                const answerCandidatesRef = collection(viewerRef, 'answerCandidates');
                onSnapshot(query(answerCandidatesRef), (snapshot) => {
                    snapshot.docChanges().forEach(async (change) => {
                        if (change.type === 'added') {
                            const candidate = new RTCIceCandidate(change.doc.data());
                            await pc.addIceCandidate(candidate);
                        }
                    });
                });
            }

            async function endBroadcast() {
                if (!db || !broadcastId) return;
                try {
                    await setDoc(doc(db, 'artifacts', appId, 'broadcasts', broadcastId), {
                        status: 'ended',
                        endedAt: serverTimestamp()
                    }, { merge: true });
                } catch (error) {
                    console.error('Error ending broadcast:', error);
                }

                if (broadcastViewerUnsubscribe) broadcastViewerUnsubscribe();
                broadcastViewerUnsubscribe = null;

                broadcastPeerConnections.forEach(pc => pc.close());
                broadcastPeerConnections.clear();

                if (broadcastStream) {
                    broadcastStream.getTracks().forEach(track => track.stop());
                    broadcastStream = null;
                }

                updateMonitorStream();

                broadcastId = null;
                setBroadcastStatus('', false);
                if (endLiveBtn) endLiveBtn.style.display = 'none';
                if (goLiveBtn) {
                    goLiveBtn.style.display = 'inline-flex';
                    goLiveBtn.disabled = false;
                }
            }

            async function joinBroadcast(broadcastDoc) {
                if (!db || !userId || !broadcastDoc?.id) return;
                if (broadcastDoc.data()?.hostId === userId) return;
                if (currentViewingBroadcastId === broadcastDoc.id) return;

                await leaveBroadcast();
                currentViewingBroadcastId = broadcastDoc.id;

                viewerPeerConnection = new RTCPeerConnection(servers);
                viewerPeerConnection.ontrack = (event) => {
                    if (event.streams && event.streams[0]) {
                        showBroadcastVideo(event.streams[0]);
                        showLocalCamera(false);
                    }
                };

                const viewerRef = doc(db, 'artifacts', appId, 'broadcasts', broadcastDoc.id, 'viewers', userId);
                await setDoc(viewerRef, {
                    viewerId: userId,
                    joinedAt: serverTimestamp()
                }, { merge: true });

                viewerPeerConnection.onicecandidate = async (event) => {
                    if (event.candidate) {
                        await addDoc(collection(viewerRef, 'answerCandidates'), event.candidate.toJSON());
                    }
                };

                onSnapshot(viewerRef, async (snapshot) => {
                    const data = snapshot.data();
                    if (data?.offer && !viewerPeerConnection.currentRemoteDescription) {
                        await viewerPeerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                        const answer = await viewerPeerConnection.createAnswer();
                        await viewerPeerConnection.setLocalDescription(answer);
                        await setDoc(viewerRef, {
                            answer: { type: answer.type, sdp: answer.sdp },
                            status: 'answered'
                        }, { merge: true });
                    }
                });

                const offerCandidatesRef = collection(viewerRef, 'offerCandidates');
                onSnapshot(query(offerCandidatesRef), (snapshot) => {
                    snapshot.docChanges().forEach(async (change) => {
                        if (change.type === 'added') {
                            const candidate = new RTCIceCandidate(change.doc.data());
                            await viewerPeerConnection.addIceCandidate(candidate);
                        }
                    });
                });
            }

            async function leaveBroadcast() {
                if (viewerPeerConnection) {
                    viewerPeerConnection.close();
                    viewerPeerConnection = null;
                }
                showBroadcastVideo(null);
                showLocalCamera(true);
                currentViewingBroadcastId = null;
            }

            function setupBroadcastListener() {
                if (!db || !userId) return;
                const liveQuery = query(
                    collection(db, 'artifacts', appId, 'broadcasts'),
                    where('status', '==', 'live'),
                    orderBy('startedAt', 'desc'),
                    limit(1)
                );

                if (liveBroadcastUnsubscribe) liveBroadcastUnsubscribe();
                liveBroadcastUnsubscribe = onSnapshot(liveQuery, (snapshot) => {
                    if (snapshot.empty) {
                        leaveBroadcast();
                        return;
                    }
                    const docSnap = snapshot.docs[0];
                    joinBroadcast(docSnap);
                });
            }
            
            const showCallOverlay = (buttonLabel = 'üìû Hang Up') => {
                if (localCallVideo) localCallVideo.style.display = 'block';
                if (remoteCallVideo) remoteCallVideo.style.display = 'block';
                if (hangupCallBtn) {
                    hangupCallBtn.style.display = 'block';
                    hangupCallBtn.textContent = buttonLabel;
                }
            };

            const hideCallOverlay = () => {
                if (localCallVideo) {
                    localCallVideo.srcObject = null;
                    localCallVideo.style.display = 'none';
                }
                if (remoteCallVideo) {
                    remoteCallVideo.srcObject = null;
                    remoteCallVideo.style.display = 'none';
                }
                if (hangupCallBtn) {
                    hangupCallBtn.style.display = 'none';
                    hangupCallBtn.textContent = 'üìû Hang Up';
                }
            };

            let incomingCallUnsubscribe = null;
            let activeCallUnsubscribe = null;
            const promptedIncomingCalls = new Set();

            const canUseCalling = () => {
                const user = auth?.currentUser;
                return isCallingEligibleUser(user) || callingUnlocked;
            };

            window.initiateCall = async function(targetUserId, targetEmail, targetDeviceId = null, targetLabel = null) {
                if (!db || !userId) return;

                if (targetUserId === userId) {
                    showMessage('You cannot call yourself. Use another signed-in account/device.');
                    return;
                }

                if (!canUseCalling()) {
                    console.warn('Calling blocked by auth gate', {
                        hasAuth: !!auth,
                        uid: auth?.currentUser?.uid || null,
                        email: auth?.currentUser?.email || null,
                        isAnonymous: auth?.currentUser?.isAnonymous,
                        providerIds: (auth?.currentUser?.providerData || []).map(p => p.providerId),
                        callingUnlocked
                    });
                    if (callStatus) callStatus.textContent = 'üîê Sign in required for calling';
                    showMessage('Please sign in with Google or email before making calls.');
                    try { switchPage('account'); } catch (e) {}
                    return;
                }
                
                try {
                    const callerDisplay = userProfile?.username || auth?.currentUser?.email || `User-${userId.slice(0, 8)}`;
                    const targetDisplay = targetLabel || targetEmail || `User-${targetUserId.slice(0, 6)}`;
                    if (callStatus) callStatus.textContent = `üìû Calling ${targetDisplay}...`;
                    
                    // Show call overlay elements
                    showCallOverlay('‚ùå Cancel Call');
                    
                    callStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: getAudioConstraints() });
                    callStream = await attachBeatToCallStream(callStream);
                    setMicEnabled(micEnabled);
                    updateMonitorStream();
                    console.log('‚úÖ LOCAL VIDEO ELEMENT:', localCallVideo.id, 'Getting local stream:', callStream.id);
                    localCallVideo.srcObject = callStream;
                    console.log('‚úÖ LOCAL VIDEO ASSIGNED');
                    console.log('üé¨ REMOTE VIDEO ELEMENT:', remoteCallVideo.id, 'Currently has:', remoteCallVideo.srcObject?.id || 'null');
                    
                    // Create peer connection
                    peerConnection = new RTCPeerConnection(servers);
                    
                    // IMPORTANT: Set up ontrack BEFORE adding tracks
                    peerConnection.ontrack = (event) => {
                        console.log('üé¨ CALLER: Remote track received:', event.track.kind, 'Streams:', event.streams.length);
                        if (event.streams && event.streams[0]) {
                            const remoteStreamId = event.streams[0].id;
                            const localStreamId = callStream?.id;
                            console.log('üéØ CALLER: REMOTE STREAM ID:', remoteStreamId);
                            console.log('üéØ CALLER: LOCAL STREAM ID:', localStreamId);
                            console.log('üéØ CALLER: DIFFERENT STREAMS?', remoteStreamId !== localStreamId);
                            
                            // Ensure we're not assigning the same stream
                            if (remoteStreamId === localStreamId) {
                                console.error('‚ùå ERROR: Remote stream is same as local stream!');
                                return;
                            }
                            
                            console.log('üé¨ CALLER: ASSIGNING REMOTE STREAM to remoteCallVideo element');
                            remoteCallVideo.srcObject = event.streams[0];
                            remoteCallVideo.play().catch(e => console.error('Remote video play error:', e));
                            console.log('üé¨ CALLER: REMOTE VIDEO NOW HAS:', remoteCallVideo.srcObject?.id);
                            console.log('üé¨ CALLER: LOCAL VIDEO STILL HAS:', localCallVideo.srcObject?.id);
                            const displayName = targetDisplay;
                            if (callStatus) callStatus.textContent = `üìû Connected to ${displayName}`;
                            if (hangupCallBtn) hangupCallBtn.textContent = 'üìû Hang Up';
                        }
                    };
                    
                    // Add local tracks (AFTER ontrack is set)
                    callStream.getTracks().forEach(track => {
                        console.log('üé§ CALLER: Adding local track:', track.kind);
                        peerConnection.addTrack(track, callStream);
                    });
                    
                    // Listen for connection state changes
                    peerConnection.onconnectionstatechange = () => {
                        console.log('üìû CALLER: Connection state:', peerConnection.connectionState);
                        if (peerConnection.connectionState === 'failed') {
                            console.error('‚ùå CALLER: Connection failed');
                            showMessage('‚ùå Connection failed. Check your network or try again.');
                        }
                    };
                    
                    peerConnection.oniceconnectionstatechange = () => {
                        console.log('üßä CALLER: ICE connection state:', peerConnection.iceConnectionState);
                    };
                    
                    peerConnection.onicegatheringstatechange = () => {
                        console.log('üßä CALLER: ICE gathering state:', peerConnection.iceGatheringState);
                    };
                    
                    // Create call document
                    const callsRef = collection(db, 'artifacts', appId, 'calls');
                    const callerDisplayName = userProfile?.username || auth?.currentUser?.email || `User-${userId.slice(0, 8)}`;
                    const callDoc = await addDoc(callsRef, {
                        caller: userId,
                        callerDeviceId: generateDeviceId(),
                        callee: targetUserId,
                        calleeDeviceId: targetDeviceId || null,
                        callerEmail: auth?.currentUser?.email || 'Anonymous',
                        callerUsername: callerDisplayName,
                        calleeEmail: targetEmail || '',
                        calleeLabel: targetDisplay,
                        status: 'calling',
                        timestamp: serverTimestamp()
                    });
                    currentCallDoc = callDoc.id;
                    console.log('üìû CALLER: Created call document with ID:', callDoc.id);

                    // Announce caller in chat so others can gift by name
                    await sendSystemChatMessage({
                        senderId: userId,
                        senderName: callerDisplayName,
                        message: 'üìû Live call started'
                    });
                    
                    // Set up ICE candidate handler BEFORE creating offer
                    peerConnection.onicecandidate = async (event) => {
                        if (event.candidate) {
                            console.log('üßä CALLER: Sending ICE candidate');
                            const candidatesRef = collection(db, 'artifacts', appId, 'calls', callDoc.id, 'offerCandidates');
                            await addDoc(candidatesRef, event.candidate.toJSON());
                        }
                    };
                    
                    // Create offer
                    console.log('üìû CALLER: Creating offer...');
                    const offerDescription = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offerDescription);
                    console.log('üìû CALLER: Offer created and set as local description');
                    
                    // Save offer to Firestore
                    await setDoc(callDoc, {
                        offer: {
                            type: offerDescription.type,
                            sdp: offerDescription.sdp
                        }
                    }, { merge: true });
                    console.log('üìû CALLER: Offer saved to Firestore');
                    
                    if (activeCallUnsubscribe) {
                        activeCallUnsubscribe();
                        activeCallUnsubscribe = null;
                    }

                    // Listen for answer and call status updates
                    activeCallUnsubscribe = onSnapshot(callDoc, async (snapshot) => {
                        const data = snapshot.data();
                        if (!data) return;

                        if (data?.answer && peerConnection && !peerConnection.currentRemoteDescription) {
                            console.log('üìû CALLER: Received answer, setting remote description');
                            const answerDescription = new RTCSessionDescription(data.answer);
                            await peerConnection.setRemoteDescription(answerDescription);
                            if (hangupCallBtn) hangupCallBtn.textContent = 'üìû Hang Up';
                        }

                        if (data?.status === 'declined') {
                            if (callStatus) callStatus.textContent = 'üìû Call declined';
                            showMessage('Call declined.');
                            if (peerConnection) {
                                peerConnection.close();
                                peerConnection = null;
                            }
                            if (callStream) {
                                callStream.getTracks().forEach(track => track.stop());
                                callStream = null;
                            }
                            hideCallOverlay();
                            currentCallDoc = null;
                        }

                        if (data?.status === 'ended') {
                            if (callStatus) callStatus.textContent = 'üìû Call ended';
                            if (peerConnection) {
                                peerConnection.close();
                                peerConnection = null;
                            }
                            if (callStream) {
                                callStream.getTracks().forEach(track => track.stop());
                                callStream = null;
                            }
                            hideCallOverlay();
                            currentCallDoc = null;
                        }
                    });
                    
                    // Listen for answer candidates
                    const answerCandidatesRef = collection(db, 'artifacts', appId, 'calls', callDoc.id, 'answerCandidates');
                    onSnapshot(query(answerCandidatesRef), (snapshot) => {
                        snapshot.docChanges().forEach(async (change) => {
                            if (change.type === 'added' && peerConnection) {
                                console.log('üßä CALLER: Received answer ICE candidate');
                                const candidate = new RTCIceCandidate(change.doc.data());
                                await peerConnection.addIceCandidate(candidate);
                            }
                        });
                    });
                    
                    showMessage(`Calling ${targetDisplay}...`);
                    
                } catch (error) {
                    console.error('Error initiating call:', error);
                    showMessage('‚ùå Could not start call. Please check camera/mic permissions.');
                    if (callStatus) callStatus.textContent = '';
                    if (peerConnection) {
                        peerConnection.close();
                        peerConnection = null;
                    }
                    if (callStream) {
                        callStream.getTracks().forEach(track => track.stop());
                        callStream = null;
                    }
                    hideCallOverlay();
                }
            };
            
            // Listen for incoming calls
            function setupIncomingCallListener() {
                if (!db || !userId) return;
                
                console.log('üìû Setting up incoming call listener for userId:', userId);
                if (incomingCallUnsubscribe) {
                    incomingCallUnsubscribe();
                    incomingCallUnsubscribe = null;
                }

                const callsQuery = query(
                    collection(db, 'artifacts', appId, 'calls'),
                    where('callee', '==', userId)
                );
                
                incomingCallUnsubscribe = onSnapshot(callsQuery, async (snapshot) => {
                    snapshot.docChanges().forEach(async (change) => {
                        if (change.type === 'added' || change.type === 'modified') {
                            const callData = change.doc.data();
                            if (callData?.status !== 'calling') return;
                            const localDeviceId = generateDeviceId();
                            if (callData?.calleeDeviceId && callData.calleeDeviceId !== localDeviceId) {
                                const tabVisible = !document.hidden && document.visibilityState === 'visible';
                                if (!tabVisible) {
                                    console.log('üìû Ignoring call for another device in hidden tab', {
                                        callId: change.doc.id,
                                        localDeviceId,
                                        targetDeviceId: callData.calleeDeviceId
                                    });
                                    return;
                                }
                                console.log('üìû Accepting call on visible fallback device', {
                                    callId: change.doc.id,
                                    localDeviceId,
                                    targetDeviceId: callData.calleeDeviceId
                                });
                            }
                            if (!callData?.calleeDeviceId && document.hidden) {
                                console.log('üìû Ignoring legacy untargeted call in hidden tab', { callId: change.doc.id });
                                return;
                            }
                            if (promptedIncomingCalls.has(change.doc.id)) return;
                            promptedIncomingCalls.add(change.doc.id);

                            const isVisibleTab = document.visibilityState === 'visible' && !document.hidden;
                            if (!isVisibleTab) {
                                console.log('üìû Incoming call ignored on hidden tab', { callId: change.doc.id });
                                return;
                            }

                            console.log('üìû Incoming call data:', callData);
                            const callerDisplay = callData.callerUsername || callData.callerEmail || 'Unknown Caller';
                            console.log('üìû Caller display name:', callerDisplay);
                            if (callStatus) callStatus.textContent = `üìû Incoming call from ${callerDisplay}...`;
                            showMessage(`Incoming call from ${callerDisplay}. Connecting...`);
                            await answerCall(change.doc.id, callData);
                        }
                    });
                }, (error) => {
                    console.error('‚ùå Incoming call listener error:', error);
                });
            }
            
            async function answerCall(callId, callData) {
                try {
                    // Show call overlay elements
                    showCallOverlay('üìû Hang Up');
                    
                    // Get local stream
                    callStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: getAudioConstraints() });
                    callStream = await attachBeatToCallStream(callStream);
                    setMicEnabled(micEnabled);
                    updateMonitorStream();
                    console.log('‚úÖ ANSWER: LOCAL VIDEO ELEMENT:', localCallVideo.id, 'Getting local stream:', callStream.id);
                    localCallVideo.srcObject = callStream;
                    console.log('‚úÖ ANSWER: LOCAL VIDEO ASSIGNED');
                    
                    // Create peer connection
                    peerConnection = new RTCPeerConnection(servers);
                    
                    // IMPORTANT: Set up ontrack BEFORE adding tracks
                    peerConnection.ontrack = (event) => {
                        console.log('üé¨ ANSWERER: Remote track received:', event.track.kind, 'Streams:', event.streams.length);
                        if (event.streams && event.streams[0]) {
                            const remoteStreamId = event.streams[0].id;
                            const localStreamId = callStream?.id;
                            console.log('üéØ ANSWERER: Remote stream ID:', remoteStreamId, 'Local stream ID:', localStreamId);
                            console.log('üéØ ANSWERER: Are they different?', remoteStreamId !== localStreamId);
                            
                            // Ensure we're not assigning the same stream
                            if (remoteStreamId === localStreamId) {
                                console.error('‚ùå ERROR: Remote stream is same as local stream!');
                                return;
                            }
                            
                            console.log('üé¨ ANSWERER: Setting remote video source');
                            remoteCallVideo.srcObject = event.streams[0];
                            remoteCallVideo.play().catch(e => console.error('Remote video play error:', e));
                            const callerName = callData.callerUsername || callData.callerEmail || 'Caller';
                            if (callStatus) callStatus.textContent = `üìû Connected to ${callerName}`;
                        }
                    };
                    
                    // Add local tracks (AFTER ontrack is set)
                    callStream.getTracks().forEach(track => {
                        console.log('üé§ ANSWERER: Adding local track to peerConnection:', track.kind, 'from stream:', callStream.id);
                        peerConnection.addTrack(track, callStream);
                    });
                    console.log('‚úÖ ANSWERER: All tracks added to peerConnection');
                    
                    // Listen for connection state changes
                    peerConnection.onconnectionstatechange = () => {
                        console.log('üìû ANSWERER: Connection state:', peerConnection.connectionState);
                        if (peerConnection.connectionState === 'failed') {
                            console.error('‚ùå ANSWERER: Connection failed');
                            showMessage('‚ùå Connection failed. Please try again.');
                        }
                    };
                    
                    peerConnection.oniceconnectionstatechange = () => {
                        console.log('üßä ANSWERER: ICE connection state:', peerConnection.iceConnectionState);
                    };
                    
                    peerConnection.onicegatheringstatechange = () => {
                        console.log('üßä ANSWERER: ICE gathering state:', peerConnection.iceGatheringState);
                    };
                    
                    // Get call document
                    const callRef = doc(db, 'artifacts', appId, 'calls', callId);
                    console.log('üìû ANSWERER: Getting call document:', callId);
                    const callSnapshot = await getDoc(callRef);
                    const callDataFromDoc = callSnapshot.data();
                    console.log('üìû ANSWERER: Call data:', callDataFromDoc);
                    
                    // Set up ICE candidate handler BEFORE creating answer
                    peerConnection.onicecandidate = async (event) => {
                        if (event.candidate) {
                            console.log('üßä ANSWERER: Sending ICE candidate');
                            const candidatesRef = collection(db, 'artifacts', appId, 'calls', callId, 'answerCandidates');
                            await addDoc(candidatesRef, event.candidate.toJSON());
                        }
                    };
                    
                    // Set remote description from offer
                    const offerDescription = callDataFromDoc.offer;
                    console.log('üìû ANSWERER: Setting remote description from offer');
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(offerDescription));
                    
                    // Create answer
                    console.log('üìû ANSWERER: Creating answer...');
                    const answerDescription = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answerDescription);
                    console.log('üìû ANSWERER: Answer created and set as local description');
                    
                    // Save answer to Firestore
                    await setDoc(callRef, {
                        answer: {
                            type: answerDescription.type,
                            sdp: answerDescription.sdp
                        },
                        status: 'connected'
                    }, { merge: true });
                    console.log('üìû ANSWERER: Answer saved to Firestore');
                    
                    // Listen for offer candidates from caller
                    console.log('üìû ANSWERER: Listening for offer candidates...');
                    const offerCandidatesRef = collection(db, 'artifacts', appId, 'calls', callId, 'offerCandidates');
                    onSnapshot(query(offerCandidatesRef), (snapshot) => {
                        snapshot.docChanges().forEach(async (change) => {
                            if (change.type === 'added') {
                                console.log('üßä ANSWERER: Received offer ICE candidate');
                                const candidate = new RTCIceCandidate(change.doc.data());
                                await peerConnection.addIceCandidate(candidate);
                            }
                        });
                    });
                    
                    currentCallDoc = callId;
                    const callerName = callData.callerUsername || callData.callerEmail || 'Caller';
                    showMessage(`Call connected with ${callerName}`);
                    
                } catch (error) {
                    console.error('Error answering call:', error);
                    showMessage('‚ùå Could not answer call.');
                }
            }
            
            if (hangupCallBtn) {
                hangupCallBtn.addEventListener('click', async () => {
                    if (peerConnection) {
                        peerConnection.close();
                        peerConnection = null;
                    }
                    
                    if (callStream) {
                        callStream.getTracks().forEach(track => track.stop());
                        callStream = null;
                    }
                    
                    hideCallOverlay();
                    
                    if (currentCallDoc) {
                        const callRef = doc(db, 'artifacts', appId, 'calls', currentCallDoc);
                        await setDoc(callRef, { status: 'ended' }, { merge: true });
                        currentCallDoc = null;
                    }
                    
                    if (callStatus) callStatus.textContent = '';
                    showMessage('Call ended');
                });
            }

            // WebRTC state variables
            let peerConnection = null;
            let callStream = null;
            let currentCallDoc = null;

            // Camera functionality
            function startCamera(forceRequest = false) {
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    console.log("Stopped existing camera stream.");
                }

                if (!localVideo) {
                    console.warn('Camera element not found: #localVideo');
                    return;
                }

                const promptMessage = document.getElementById('prompt-message');
                const constraints = {
                    video: {
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        facingMode: 'user'
                    },
                    audio: getAudioConstraints()
                };

                navigator.mediaDevices.getUserMedia(constraints)
                    .then(stream => {
                        localStream = stream;
                        localVideo.srcObject = stream;
                        localVideo.muted = true;
                        const playAttempt = localVideo.play();
                        if (playAttempt && typeof playAttempt.catch === 'function') {
                            playAttempt.catch(err => {
                                console.warn('Autoplay blocked:', err.message);
                            });
                        }
                        if (promptMessage) {
                            promptMessage.textContent = 'Camera and microphone are ready.';
                        }
                        console.log("Camera stream started.");
                    })
                    .catch(err => {
                        console.warn("Camera not available:", err.message);
                        // Camera is optional - app continues without it
                        // User can still see team photos and use other features
                        let errorMessage = `Camera not available (${err.name}). You can still use the app without camera.`;
                        if (err.name === 'NotAllowedError') {
                            errorMessage = "Camera/microphone access was denied. Click üé• Enable Camera to allow permissions.";
                        } else if (err.name === 'NotFoundError') {
                            errorMessage = "No camera/microphone found on this device. You can still use the app.";
                        }
                        console.log(errorMessage);
                        if (promptMessage) {
                            promptMessage.textContent = errorMessage;
                        }
                        // Don't show blocking message - let app continue
                    });
            }

            // Initialize Firebase and setup
            async function setupFirebaseApp() {
                await resolveFirebaseConfig();
                if (Object.keys(firebaseConfig).length) {
                    appId = firebaseConfig.projectId || (typeof window.__app_id !== 'undefined' ? window.__app_id : 'raydent-app');
                    const app = initializeApp(firebaseConfig);
                    const initFirestoreWithFallback = () => {
                        try {
                            return initializeFirestore(app, {
                                experimentalForceLongPolling: true,
                                useFetchStreams: false
                            });
                        } catch (e) {
                            console.warn('initializeFirestore failed, falling back to getFirestore:', e);
                            return getFirestore(app);
                        }
                    };

                    db = initFirestoreWithFallback();
                    auth = getAuth(app);
                    try {
                        await setPersistence(auth, browserSessionPersistence);
                        console.log('‚úÖ Auth persistence set to browserSessionPersistence (tab/session isolated)');
                    } catch (e) {
                        console.warn('Could not set auth session persistence:', e);
                    }
                    
                    // Expose db and Firestore functions to window for console debugging
                    window.db = db;
                    window.fsDoc = doc;
                    window.fsGetDoc = getDoc;
                    window.fsSetDoc = setDoc;
                    window.fsUpdateDoc = updateDoc;
                    
                    // Debug helper - paste in console: checkProfile()
                    window.checkProfile = async () => {
                        if (!window.userId) {
                            console.log('‚ùå userId not set yet');
                            return;
                        }
                        console.log('üîç Checking profile for user:', window.userId);
                        const publicProfile = await window.fsGetDoc(window.fsDoc(window.db, 'artifacts', window.appId, 'public', 'data', 'profiles', window.userId));
                        console.log('üìÑ Public profile:', publicProfile.exists() ? publicProfile.data() : 'NOT FOUND');
                        const privateProfile = await window.fsGetDoc(window.fsDoc(window.db, 'artifacts', window.appId, 'users', window.userId, 'profile', 'data'));
                        console.log('üìÑ Private profile:', privateProfile.exists() ? privateProfile.data() : 'NOT FOUND');
                        const presence = await window.fsGetDoc(window.fsDoc(window.db, 'artifacts', window.appId, 'presence', window.userId));
                        console.log('üìÑ Presence:', presence.exists() ? presence.data() : 'NOT FOUND');
                    };
                    console.log('‚úÖ checkProfile() function is now available. Type checkProfile() in console to use it.');

                    // Complete redirect login BEFORE anything else
                    async function completeRedirectLogin() {
                        try {
                            console.log('üîç Checking for pending Google redirect...');
                            const result = await getRedirectResult(auth);
                            if (result && result.user) {
                                console.log('‚úÖ Google redirect login completed:', result.user.email);
                                console.log('‚úÖ User successfully signed in:', result.user.uid);
                                if (result.user.email) {
                                    showMessage(`Google sign-in successful: ${result.user.email}`);
                                } else {
                                    showMessage('Google sign-in successful');
                                }
                                return result.user;
                            } else {
                                console.log('‚ÑπÔ∏è No pending Google redirect found');
                            }
                        } catch (error) {
                            console.error('‚ùå Redirect result error:', error);
                            console.error('Error code:', error.code);
                            console.error('Error message:', error.message);
                            // Log but don't fail - user might just not be coming back from Google auth
                            if (error.code !== 'auth/redirect-cancelled-by-user') {
                                console.warn('‚ö†Ô∏è Redirect error (not critical):', error.message);
                                showMessage(`Google sign-in failed: ${error.message}`);
                            }
                        }
                    }

                    await completeRedirectLogin();
                    
                    onAuthStateChanged(auth, async (user) => {
                        if (!user) {
                            try {
                                if (initialAuthToken) {
                                    await signInWithCustomToken(auth, initialAuthToken);
                                } else {
                                    await signInAnonymously(auth);
                                }
                            } catch (error) {
                                console.error("Firebase Auth Error:", error);
                                console.warn("‚ö†Ô∏è Anonymous auth failed. Using fallback UUID. Check Firestore Security Rules.");
                            }
                        }
                        userId = auth.currentUser?.uid || crypto.randomUUID();
                        window.userId = userId;
                        window.appId = appId;
                        console.log("‚úÖ userId set to:", userId, "| Authenticated:", !!auth.currentUser);
                        if(userIdDisplay) userIdDisplay.textContent = userId;
                        updateAuthUI(auth.currentUser);

                        try {
                            const returnPage = sessionStorage.getItem('authReturnPage');
                            if (returnPage) {
                                switchPage(returnPage);
                                sessionStorage.removeItem('authReturnPage');
                            }
                        } catch (e) {}
                        
                        // Load user profile FIRST before setting up chat listener
                        await loadUserProfile();
                        
                        // Clear profile cache to ensure fresh data
                        Object.keys(userProfileCache).forEach(key => delete userProfileCache[key]);
                        
                        dlog('üöÄ ABOUT TO SETUP: cameraChatListener, presence, incomingCalls...');
                        setupCameraChatListener();
                        dlog('üöÄ Calling setupOnlinePresence() now...');
                        await setupOnlinePresence();
                        dlog('üöÄ setupOnlinePresence() completed');
                        setupIncomingCallListener();
                        setupBroadcastListener();
                        loadUserBalance();
                        listenForGiftReceipts();
                        loadTeamPhotos();
                        loadTeamPhotos();

                        // Auto Go Live on entry (host mode only)
                        setTimeout(() => {
                            if (autoGoLiveEnabled && !broadcastId) {
                                startBroadcast();
                            }
                        }, 800);
                    });
                } else {
                    showMessage('Firebase config missing. Add Firebase Hosting config or set __firebase_config.');
                }
            }
            
            await setupFirebaseApp();
                        await loadBeats();
            
            
            startCamera();

            // Stop camera on page unload
            window.addEventListener('beforeunload', () => {
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    console.log("Camera stream stopped on page unload.");
                }
                if (broadcastStream) {
                    broadcastStream.getTracks().forEach(track => track.stop());
                }
                if (broadcastId && db) {
                    try {
                        setDoc(doc(db, 'artifacts', appId, 'broadcasts', broadcastId), {
                            status: 'ended',
                            endedAt: serverTimestamp()
                        }, { merge: true });
                    } catch (e) {
                        console.warn('Failed to mark broadcast ended on unload:', e);
                    }
                }
            });

            // === RHYME GENERATOR FUNCTIONS ===
            
            let zodiacData = null;
            const signLyricsCache = {};
            const PISCES_GHOST_LYRICS_SIGN = 'aquarius';
            const FIRST_LADY_LYRICS_SIGN = 'first-lady';
            
            // Load zodiac data
            async function loadZodiacData() {
                try {
                    const response = await fetch('/assets/lyrics/zodiac-data.json');
                    zodiacData = await response.json();
                    console.log('Zodiac data loaded:', zodiacData);
                } catch (error) {
                    console.error('Error loading zodiac data:', error);
                }
            }

            async function loadSignLyrics(sign) {
                const normalizedSign = (sign || '').toLowerCase();
                if (signLyricsCache[normalizedSign]) return signLyricsCache[normalizedSign];

                try {
                    const response = await fetch(`/assets/lyrics/${normalizedSign}-lyrics.json`);
                    if (!response.ok) throw new Error(`Missing lyrics file for ${normalizedSign}`);
                    const data = await response.json();
                    signLyricsCache[normalizedSign] = data;
                    return data;
                } catch (error) {
                    console.warn(`No lyric file found for ${normalizedSign}:`, error.message);
                    signLyricsCache[normalizedSign] = null;
                    return null;
                }
            }
            
            // Generate rhyme coaching using Gemini AI
            async function generateRhymeCoaching() {
                const userSign = document.getElementById('user-zodiac-sign')?.value;
                const userRhyme = document.getElementById('user-rhyme-input')?.value?.trim();
                const rhymeOutput = document.getElementById('rhyme-output');
                const rhymeResult = document.getElementById('rhyme-result');
                const generateBtn = document.getElementById('generate-rhyme-btn');
                
                if (!userRhyme) {
                    showMessage('Please enter your rhyme first!');
                    return;
                }
                
                if (!zodiacData) {
                    showMessage('Loading zodiac data...');
                    await loadZodiacData();
                }
                
                generateBtn.textContent = '‚ú® Generating...';
                generateBtn.disabled = true;
                
                try {
                    // Get compatible signs and characteristics
                    const compatibleSigns = zodiacData.zodiacCompatibility[userSign] || [];
                    const userCharacteristics = zodiacData.signCharacteristics[userSign] || [];

                    // Load lyrics for user's sign (AI council) or fallback to AI-only
                    const councilLyricsData = await loadSignLyrics(userSign);
                    const councilLyrics = (councilLyricsData?.lyrics || []).filter(Boolean);

                    // Pisces Ghost (Baby Ray) uses Aquarius lyrics for unique character
                    const piscesGhostLyricsData = await loadSignLyrics(PISCES_GHOST_LYRICS_SIGN);
                    const piscesGhostLyrics = (piscesGhostLyricsData?.lyrics || []).filter(Boolean);

                    // First Lady placeholder lyrics (if provided)
                    const firstLadyLyricsData = await loadSignLyrics(FIRST_LADY_LYRICS_SIGN);
                    const firstLadyLyrics = (firstLadyLyricsData?.lyrics || []).filter(Boolean);
                    
                    // Build coaching prompt based on Pisces perspective and user's zodiac
                    const prompt = `You are Antonio, a Pisces rapper/coach teaching someone to rhyme from a Pisces perspective.

USER INFO:
- Zodiac Sign: ${userSign}
- Their Characteristics: ${userCharacteristics.join(', ')}
- Compatible Signs: ${compatibleSigns.join(', ')}

PISCES GHOST (BABY RAY) LYRICS (Aquarius-coded):
${piscesGhostLyrics.length ? piscesGhostLyrics.slice(0, 8).join('\n') : 'No custom Pisces Ghost lyrics yet.'}

COUNCIL AI RHYMES (User Sign Library):
${councilLyrics.length ? councilLyrics.slice(0, 6).join('\n') : 'No custom council lyrics for this sign yet.'}

FIRST LADY PLACEHOLDER LYRICS:
${firstLadyLyrics.length ? firstLadyLyrics.slice(0, 4).join('\n') : 'No First Lady lyrics yet.'}

THEIR RHYME:
${userRhyme}

COACHING STYLE:
As a Pisces, teach them using:
- Intuition and emotional depth
- Creative flow and imagery
- Empathy and understanding
- Dream-like, flowing language

Provide:
1. What's working in their rhyme (be encouraging)
2. How their ${userSign} characteristics can enhance their flow
3. A 4-line rhyme example that blends Pisces style with ${userSign} energy
4. One specific tip to improve their bars

Keep it real, encouraging, and creative. Make it feel like Antonio's coaching them personally.`;

                    // Call Gemini API
                    const apiKey = 'AIzaSyA9Rl785wVd6NVgdNqU_5lsy36dHYnLMlE'; // Your existing API key
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{ text: prompt }]
                            }]
                        })
                    });
                    
                    const data = await response.json();
                    const coaching = data.candidates?.[0]?.content?.parts?.[0]?.text || 'Error generating coaching. Try again!';
                    
                    rhymeResult.textContent = coaching;
                    rhymeOutput.style.display = 'block';
                    
                } catch (error) {
                    console.error('Error generating rhyme coaching:', error);
                    showMessage('Error generating coaching. Please try again.');
                } finally {
                    generateBtn.textContent = '‚ú® Get Pisces Coaching';
                    generateBtn.disabled = false;
                }
            }
            
            // Setup rhyme generator button
            document.getElementById('generate-rhyme-btn')?.addEventListener('click', generateRhymeCoaching);
            
            // === BEAT PLAYER SETUP ===
            const beatPlaylist = [
                { name: 'SBM BEAT 1', src: '/assets/SBM BEAT 1.mp4' },
                { name: 'SBM BEAT 2', src: '/assets/SBM BEAT 2.mp4' },
                { name: 'SBM BEAT 3', src: '/assets/SBM BEAT 3.mp4' },
                { name: 'SBM Beat 4', src: '/assets/SBM Beat 4.mp4' },
                { name: 'SBM BEAT 5', src: '/assets/SBM BEAT 5.mp4' },
                { name: 'SBM BEAT 7', src: '/assets/SBM BEAT 7.mp4' },
                { name: 'SBM BEAT 8', src: '/assets/SBM BEAT 8.mp4' },
                { name: 'SBM BEAT 9', src: '/assets/SBM BEAT 9.mp4' },
                { name: 'SBM BEAT 13 RNB VIBE', src: '/assets/SBM BEAT 13 RNB VIBE 130 bpm.mp4' },
                { name: 'SBM BEAT 14', src: '/assets/SBM BEAT 14 145.56 bpm (BLACK LABEL).mp4' },
                { name: 'SBM beat 15', src: '/assets/SBM beat 15 140 bpm (BLACK LABEL).mp4' },
                { name: 'Beat 16', src: '/assets/Beat 16 140 bpm (BLACK LABEL).mp4' },
                { name: 'SBM BEAT 17', src: '/assets/SBM BEAT 17.mp4' },
                { name: 'SBM BEAT 18', src: '/assets/SBM BEAT 18.mp4' },
                { name: 'We Still Low', src: '/assets/We still low.mp4' },
                { name: 'Worldwide Mafia GOODFELLAHZ', src: '/assets/worldwide mafia GOODFELLAHZ entertainment (1).mp4' },
                { name: 'Worldwide Mafia PRINCESSES', src: '/assets/worldwide mafia PRINCESSES entertainment.mp4' },
                { name: 'Gucci Mane Letter to Take', src: '/assets/guccimane letter to take.mp4' },
                { name: 'Beat 3', src: '/assets/beat3.mp4' },
                { name: 'Beat 4', src: '/assets/beat4.mp4' }
            ];

            let currentBeatIndex = 0;

            function loadBeatIntoPlayer(beatUrl, beatName = 'Beat') {
                if (!customPlayer) {
                    console.error('Video player not initialized');
                    return;
                }
                try {
                    customPlayer.src({
                        src: beatUrl,
                        type: 'video/mp4'
                    });
                    customPlayer.play();
                    if (beatNameDisplay) {
                        beatNameDisplay.textContent = `Now Playing: ${beatName}`;
                    }
                    console.log('‚úÖ Beat loaded:', beatUrl);
                } catch (error) {
                    console.error('Error loading beat:', error);
                    showMessage('Error loading beat player.');
                }
            }

            function playNextBeat() {
                currentBeatIndex = (currentBeatIndex + 1) % beatPlaylist.length;
                const beat = beatPlaylist[currentBeatIndex];
                loadBeatIntoPlayer(beat.src, beat.name);
            }

            if (customPlayer) {
                // Auto-play next beat when current one ends
                customPlayer.on('ended', () => {
                    console.log('Beat ended, playing next...');
                    playNextBeat();
                });

                // Load first beat on page load
                setTimeout(() => {
                    const firstBeat = beatPlaylist[0];
                    loadBeatIntoPlayer(firstBeat.src, firstBeat.name);
                }, 1000);
            } else {
                console.warn('Video.js not available; beat player disabled.');
            }

            // === BEAT UPLOAD HANDLER ===
            document.getElementById('beat-upload')?.addEventListener('change', (e) => {
                const file = e.target.files?.[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const dataURL = event.target?.result;
                    if (dataURL) {
                        loadBeatIntoPlayer(dataURL, file.name);
                        showMessage('‚ú® Beat loaded into player!');
                    }
                };
                reader.readAsDataURL(file);
            });

            // === END BEAT PLAYER SETUP ===


            // === APPROVE GOODDGIRL BUTTON ===
            approveBaddgirlBtn?.addEventListener('click', async () => {
                if (!adminMode) {
                    showMessage('This is an admin-only action. Enable Admin Mode first.');
                    return;
                }
                try {
                    await setDoc(doc(db, 'artifacts', appId, 'public', 'data'), 
                        { baddgirlApproved: true, approvedAt: serverTimestamp() }, 
                        { merge: true }
                    );
                    baddgirlStatus.textContent = 'Approved ‚ú®';
                    baddgirlStatus.className = 'badge status-approved';
                    approveBaddgirlBtn.disabled = true;
                    approveBaddgirlBtn.textContent = '‚ú® Approved';
                    showMessage('GoodDGirl has been approved and can now enter the studio!');
                } catch (error) {
                    console.error('Error approving GoodDGirl:', error);
                    showMessage('Error approving GoodDGirl.');
                }
            });

            // === PURCHASE BEAT BUTTON ===
            purchaseBeatBtn?.addEventListener('click', () => {
                if (userBalance >= 5) {
                    showMessage('You already own this beat!');
                } else {
                    showMessage('You need 5 credits to purchase this beat. Visit the Account tab to buy balance.');
                    openBalanceModal();
                }
            });

            // === END OF DOMCONTENTLOADED ===
        });
    </script>
</body>
</html>
